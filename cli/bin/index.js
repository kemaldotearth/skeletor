#!/usr/bin/env node
'use strict';
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) =>
  function __require() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target,
    mod,
  )
);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) =>
      x.done
        ? resolve(x.value)
        : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../node_modules/commander/lib/error.js
var require_error = __commonJS({
  '../node_modules/commander/lib/error.js'(exports2) {
    var CommanderError2 = class extends Error {
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      constructor(message) {
        super(1, 'commander.invalidArgument', message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
  },
});

// ../node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  '../node_modules/commander/lib/argument.js'(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      constructor(name, description) {
        this.description = description || '';
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case '<':
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case '[':
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === '...') {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      name() {
        return this._name;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(', ')}.`,
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      argRequired() {
        this.required = true;
        return this;
      }
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');
      return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
    }
    exports2.Argument = Argument2;
    exports2.humanReadableArgName = humanReadableArgName;
  },
});

// ../node_modules/commander/lib/help.js
var require_help = __commonJS({
  '../node_modules/commander/lib/help.js'(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
      }
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] =
            cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs) helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag =
          cmd._hasHelpOption &&
          cmd._helpShortFlag &&
          !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag =
          cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(
              cmd._helpLongFlag,
              cmd._helpDescription,
            );
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(
              cmd._helpShortFlag,
              cmd._helpDescription,
            );
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          const getSortKey = (option) => {
            return option.short
              ? option.short.replace(/^-/, '')
              : option.long.replace(/^--/, '');
          };
          visibleOptions.sort((a, b) => {
            return getSortKey(a).localeCompare(getSortKey(b));
          });
        }
        return visibleOptions;
      }
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description =
              argument.description ||
              cmd._argsDescription[argument.name()] ||
              '';
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        return [];
      }
      subcommandTerm(cmd) {
        const args = cmd._args
          .map((arg) => humanReadableArgName(arg))
          .join(' ');
        return (
          cmd._name +
          (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
          (cmd.options.length ? ' [options]' : '') +
          (args ? ' ' + args : '')
        );
      }
      optionTerm(option) {
        return option.flags;
      }
      argumentTerm(argument) {
        return argument.name();
      }
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + '|' + cmd._aliases[0];
        }
        let parentCmdNames = '';
        for (
          let parentCmd = cmd.parent;
          parentCmd;
          parentCmd = parentCmd.parent
        ) {
          parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
        }
        return parentCmdNames + cmdName + ' ' + cmd.usage();
      }
      commandDescription(cmd) {
        return cmd.description();
      }
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            `choices: ${option.argChoices
              .map((choice) => JSON.stringify(choice))
              .join(', ')}`,
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault =
            option.required ||
            option.optional ||
            (option.isBoolean() && typeof option.defaultValue === 'boolean');
          if (showDefault) {
            extraInfo.push(
              `default: ${
                option.defaultValueDescription ||
                JSON.stringify(option.defaultValue)
              }`,
            );
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(', ')})`;
        }
        return option.description;
      }
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            `choices: ${argument.argChoices
              .map((choice) => JSON.stringify(choice))
              .join(', ')}`,
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(
            `default: ${
              argument.defaultValueDescription ||
              JSON.stringify(argument.defaultValue)
            }`,
          );
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(', ')})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(
              termWidth + itemSeparatorWidth,
            )}${description}`;
            return helper.wrap(
              fullText,
              helpWidth - itemIndentWidth,
              termWidth + itemSeparatorWidth,
            );
          }
          return term;
        }
        function formatList(textArray) {
          return textArray
            .join('\n')
            .replace(/^/gm, ' '.repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([commandDescription, '']);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(
            helper.argumentTerm(argument),
            helper.argumentDescription(argument),
          );
        });
        if (argumentList.length > 0) {
          output = output.concat(['Arguments:', formatList(argumentList), '']);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option),
          );
        });
        if (optionList.length > 0) {
          output = output.concat(['Options:', formatList(optionList), '']);
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(
            helper.subcommandTerm(cmd2),
            helper.subcommandDescription(cmd2),
          );
        });
        if (commandList.length > 0) {
          output = output.concat(['Commands:', formatList(commandList), '']);
        }
        return output.join('\n');
      }
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper),
        );
      }
      wrap(str, width, indent, minColumnWidth = 40) {
        if (str.match(/[\n]\s+/)) return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth) return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent);
        const indentString = ' '.repeat(indent);
        const regex = new RegExp(
          '.{1,' +
            (columnWidth - 1) +
            '}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)',
          'g',
        );
        const lines = columnText.match(regex) || [];
        return (
          leadingStr +
          lines
            .map((line, i) => {
              if (line.slice(-1) === '\n') {
                line = line.slice(0, line.length - 1);
              }
              return (i > 0 ? indentString : '') + line.trimRight();
            })
            .join('\n')
        );
      }
    };
    exports2.Help = Help2;
  },
});

// ../node_modules/commander/lib/option.js
var require_option = __commonJS({
  '../node_modules/commander/lib/option.js'(exports2) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || '';
        this.required = flags.includes('<');
        this.optional = flags.includes('[');
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith('--no-');
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      implies(impliedOptionValues) {
        this.implied = Object.assign(this.implied || {}, impliedOptionValues);
        return this;
      }
      env(name) {
        this.envVar = name;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(
              `Allowed choices are ${this.argChoices.join(', ')}.`,
            );
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      name() {
        if (this.long) {
          return this.long.replace(/^--/, '');
        }
        return this.short.replace(/^-/, '');
      }
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ''));
      }
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split('-').reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option2;
    exports2.splitOptionFlags = splitOptionFlags;
    exports2.DualOptions = DualOptions;
  },
});

// ../node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  '../node_modules/commander/lib/suggestSimilar.js'(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            d[i][j - 1] + 1,
            d[i - 1][j - 1] + cost,
          );
          if (
            i > 1 &&
            j > 1 &&
            a[i - 1] === b[j - 2] &&
            a[i - 2] === b[j - 1]
          ) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return '';
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith('--');
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1) return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(', ')}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return '';
    }
    exports2.suggestSimilar = suggestSimilar;
  },
});

// ../node_modules/commander/lib/command.js
var require_command = __commonJS({
  '../node_modules/commander/lib/command.js'(exports2) {
    var EventEmitter = require('events').EventEmitter;
    var childProcess = require('child_process');
    var path = require('path');
    var fs2 = require('fs');
    var process9 = require('process');
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter {
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || '';
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = '';
        this._summary = '';
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process9.stdout.write(str),
          writeErr: (str) => process9.stderr.write(str),
          getOutHelpWidth: () =>
            process9.stdout.isTTY ? process9.stdout.columns : void 0,
          getErrHelpWidth: () =>
            process9.stderr.isTTY ? process9.stderr.columns : void 0,
          outputError: (str, write) => write(str),
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = '-h, --help';
        this._helpDescription = 'display help for command';
        this._helpShortFlag = '-h';
        this._helpLongFlag = '--help';
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = 'help';
        this._helpCommandnameAndArgs = 'help [command]';
        this._helpCommandDescription = 'display help for command';
        this._helpConfiguration = {};
      }
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties =
          sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue =
          sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError =
          sourceCommand._showSuggestionAfterError;
        return this;
      }
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === 'object' && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args) cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc) return this;
        return cmd;
      }
      createCommand(name) {
        return new Command2(name);
      }
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      configureHelp(configuration) {
        if (configuration === void 0) return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      configureOutput(configuration) {
        if (configuration === void 0) return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === 'function') {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(
            `only the last argument can be variadic '${previousArgument.name()}'`,
          );
        }
        if (
          argument.required &&
          argument.defaultValue !== void 0 &&
          argument.parseArg === void 0
        ) {
          throw new Error(
            `a default value for a required argument is never used: '${argument.name()}'`,
          );
        }
        this._args.push(argument);
        return this;
      }
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === 'string') {
            this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription =
            description || this._helpCommandDescription;
        }
        return this;
      }
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return (
            this.commands.length &&
            !this._actionHandler &&
            !this._findCommand('help')
          );
        }
        return this._addImplicitHelpCommand;
      }
      hook(event, listener) {
        const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== 'commander.executeSubCommandAsync') {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process9.exit(exitCode);
      }
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, '--');
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === void 0 ? true : option.defaultValue,
              'default',
            );
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, 'default');
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue);
            } catch (err) {
              if (err.code === 'commander.invalidArgument') {
                const message = `${invalidValueMessage} ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = '';
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on('option:' + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, 'cli');
        });
        if (option.envVar) {
          this.on('optionEnv:' + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, 'env');
          });
        }
        return this;
      }
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === 'object' && flags instanceof Option2) {
          throw new Error(
            'To add an Option object use addOption() instead of option() or requiredOption()',
          );
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === 'function') {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx(
          { mandatory: true },
          flags,
          description,
          fn,
          defaultValue,
        );
      }
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (
          !!this.parent &&
          passThrough &&
          !this.parent._enablePositionalOptions
        ) {
          throw new Error(
            'passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)',
          );
        }
        return this;
      }
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error(
            'call .storeOptionsAsProperties() before adding options',
          );
        }
        return this;
      }
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error(
            'first parameter to parse must be array or undefined',
          );
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process9.argv;
          if (process9.versions && process9.versions.electron) {
            parseOptions.from = 'electron';
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case 'node':
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case 'electron':
            if (process9.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case 'user':
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(
              `unexpected parse option { from: '${parseOptions.from}' }`,
            );
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || 'program';
        return userArgs;
      }
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];
        function findFile(baseDir, baseName) {
          const localBin = path.resolve(baseDir, baseName);
          if (fs2.existsSync(localBin)) return localBin;
          if (sourceExt.includes(path.extname(baseName))) return void 0;
          const foundExt = sourceExt.find((ext) =>
            fs2.existsSync(`${localBin}${ext}`),
          );
          if (foundExt) return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile =
          subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || '';
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs2.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path.resolve(
            path.dirname(resolvedScriptPath),
            executableDir,
          );
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path.basename(
              this._scriptPath,
              path.extname(this._scriptPath),
            );
            if (legacyName !== this._name) {
              localFile = findFile(
                executableDir,
                `${legacyName}-${subcommand._name}`,
              );
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path.extname(executableFile));
        let proc;
        if (process9.platform !== 'win32') {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process9.execArgv).concat(args);
            proc = childProcess.spawn(process9.argv[0], args, {
              stdio: 'inherit',
            });
          } else {
            proc = childProcess.spawn(executableFile, args, {
              stdio: 'inherit',
            });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process9.execArgv).concat(args);
          proc = childProcess.spawn(process9.execPath, args, {
            stdio: 'inherit',
          });
        }
        if (!proc.killed) {
          const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
          signals.forEach((signal) => {
            process9.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on('close', process9.exit.bind(process9));
        } else {
          proc.on('close', () => {
            exitCallback(
              new CommanderError2(
                process9.exitCode || 0,
                'commander.executeSubCommandAsync',
                '(close)',
              ),
            );
          });
        }
        proc.on('error', (err) => {
          if (err.code === 'ENOENT') {
            const executableDirMessage = executableDir
              ? `searched for local subcommand relative to directory '${executableDir}'`
              : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === 'EACCES') {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process9.exit(1);
          } else {
            const wrappedError = new CommanderError2(
              1,
              'commander.executeSubCommandAsync',
              '(error)',
            );
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });
        let hookResult;
        hookResult = this._chainOrCallSubCommandHook(
          hookResult,
          subCommand,
          'preSubcommand',
        );
        hookResult = this._chainOrCall(hookResult, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return hookResult;
      }
      _checkNumberOfArguments() {
        this._args.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (
          this._args.length > 0 &&
          this._args[this._args.length - 1].variadic
        ) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === 'commander.invalidArgument') {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${
                  err.message
                }`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === 'function') {
          return promise.then(() => fn());
        }
        return fn();
      }
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this)
          .reverse()
          .filter((cmd) => cmd._lifeCycleHooks[event] !== void 0)
          .forEach((hookedCommand) => {
            hookedCommand._lifeCycleHooks[event].forEach((callback) => {
              hooks.push({ hookedCommand, callback });
            });
          });
        if (event === 'postAction') {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(
            operands[0],
            operands.slice(1),
            unknown,
          );
        }
        if (
          this._hasImplicitHelpCommand() &&
          operands[0] === this._helpCommandName
        ) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(
            operands[1],
            [],
            [this._helpLongFlag],
          );
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(
            this._defaultCommandName,
            operands,
            unknown,
          );
        }
        if (
          this.commands.length &&
          this.args.length === 0 &&
          !this._actionHandler &&
          !this._defaultCommandName
        ) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, 'preAction');
          actionResult = this._chainOrCall(actionResult, () =>
            this._actionHandler(this.processedArgs),
          );
          if (this.parent) {
            actionResult = this._chainOrCall(actionResult, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          actionResult = this._chainOrCallHooks(actionResult, 'postAction');
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand('*')) {
            return this._dispatchSubcommand('*', operands, unknown);
          }
          if (this.listenerCount('command:*')) {
            this.emit('command:*', operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      _findCommand(name) {
        if (!name) return void 0;
        return this.commands.find(
          (cmd) => cmd._name === name || cmd._aliases.includes(name),
        );
      }
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (
              anOption.mandatory &&
              cmd.getOptionValue(anOption.attributeName()) === void 0
            ) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter((option) => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === void 0) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== 'default';
        });
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0,
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName()),
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      _checkForConflictingOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd._checkForConflictingLocalOptions();
        }
      }
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === '-';
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === '--') {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (
                option.required ||
                (option.optional && this._combineFlagAndOptionalValue)
              ) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf('=');
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if (
            (this._enablePositionalOptions || this._passThroughOptions) &&
            operands.length === 0 &&
            unknown.length === 0
          ) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (
              arg === this._helpCommandName &&
              this._hasImplicitHelpCommand()
            ) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] =
              key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      optsWithGlobals() {
        return getCommandAndParents(this).reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {},
        );
      }
      error(message, errorOptions) {
        this._outputConfiguration.outputError(
          `${message}
`,
          this._outputConfiguration.writeErr,
        );
        if (typeof this._showHelpAfterError === 'string') {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr('\n');
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || 'commander.error';
        this._exit(exitCode, code, message);
      }
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process9.env) {
            const optionKey = option.attributeName();
            if (
              this.getOptionValue(optionKey) === void 0 ||
              ['default', 'config', 'env'].includes(
                this.getOptionValueSource(optionKey),
              )
            ) {
              if (option.required || option.optional) {
                this.emit(
                  `optionEnv:${option.name()}`,
                  process9.env[option.envVar],
                );
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return (
            this.getOptionValue(optionKey) !== void 0 &&
            !['default', 'implied'].includes(
              this.getOptionValueSource(optionKey),
            )
          );
        };
        this.options
          .filter(
            (option) =>
              option.implied !== void 0 &&
              hasCustomOptionValue(option.attributeName()) &&
              dualHelper.valueFromOption(
                this.getOptionValue(option.attributeName()),
                option,
              ),
          )
          .forEach((option) => {
            Object.keys(option.implied)
              .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
              .forEach((impliedKey) => {
                this.setOptionValueWithSource(
                  impliedKey,
                  option.implied[impliedKey],
                  'implied',
                );
              });
          });
      }
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: 'commander.missingArgument' });
      }
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: 'commander.optionMissingArgument' });
      }
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: 'commander.missingMandatoryOptionValue' });
      }
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(
            (target) => target.negate && optionKey === target.attributeName(),
          );
          const positiveOption = this.options.find(
            (target) => !target.negate && optionKey === target.attributeName(),
          );
          if (
            negativeOption &&
            ((negativeOption.presetArg === void 0 && optionValue === false) ||
              (negativeOption.presetArg !== void 0 &&
                optionValue === negativeOption.presetArg))
          ) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === 'env') {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(
          option,
        )} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: 'commander.conflictingOption' });
      }
      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = '';
        if (flag.startsWith('--') && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command
              .createHelp()
              .visibleOptions(command)
              .filter((option) => option.long)
              .map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: 'commander.unknownOption' });
      }
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;
        const expected = this._args.length;
        const s = expected === 1 ? '' : 's';
        const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: 'commander.excessArguments' });
      }
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = '';
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp()
            .visibleCommands(this)
            .forEach((command) => {
              candidateNames.push(command.name());
              if (command.alias()) candidateNames.push(command.alias());
            });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: 'commander.unknownCommand' });
      }
      version(str, flags, description) {
        if (str === void 0) return this._version;
        this._version = str;
        flags = flags || '-V, --version';
        description = description || 'output the version number';
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on('option:' + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, 'commander.version', str);
        });
        return this;
      }
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      summary(str) {
        if (str === void 0) return this._summary;
        this._summary = str;
        return this;
      }
      alias(alias) {
        if (alias === void 0) return this._aliases[0];
        let command = this;
        if (
          this.commands.length !== 0 &&
          this.commands[this.commands.length - 1]._executableHandler
        ) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      aliases(aliases) {
        if (aliases === void 0) return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      usage(str) {
        if (str === void 0) {
          if (this._usage) return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return []
            .concat(
              this.options.length || this._hasHelpOption ? '[options]' : [],
              this.commands.length ? '[command]' : [],
              this._args.length ? args : [],
            )
            .join(' ');
        }
        this._usage = str;
        return this;
      }
      name(str) {
        if (str === void 0) return this._name;
        this._name = str;
        return this;
      }
      nameFromFilename(filename) {
        this._name = path.basename(filename, path.extname(filename));
        return this;
      }
      executableDir(path2) {
        if (path2 === void 0) return this._executableDir;
        this._executableDir = path2;
        return this;
      }
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth =
            contextOptions && contextOptions.error
              ? this._outputConfiguration.getErrHelpWidth()
              : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === 'function') {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this)
          .reverse()
          .forEach((command) => command.emit('beforeAllHelp', context));
        this.emit('beforeHelp', context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (
            typeof helpInformation !== 'string' &&
            !Buffer.isBuffer(helpInformation)
          ) {
            throw new Error(
              'outputHelp callback must return a string or a Buffer',
            );
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit('afterHelp', context);
        getCommandAndParents(this).forEach((command) =>
          command.emit('afterAllHelp', context),
        );
      }
      helpOption(flags, description) {
        if (typeof flags === 'boolean') {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process9.exitCode || 0;
        if (
          exitCode === 0 &&
          contextOptions &&
          typeof contextOptions !== 'function' &&
          contextOptions.error
        ) {
          exitCode = 1;
        }
        this._exit(exitCode, 'commander.help', '(outputHelp)');
      }
      addHelpText(position, text) {
        const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === 'function') {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption =
        cmd._hasHelpOption &&
        args.find(
          (arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag,
        );
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith('--inspect')) {
          return arg;
        }
        let debugOption;
        let debugHost = '127.0.0.1';
        let debugPort = '9229';
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if (
          (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
        ) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if (
          (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !==
          null
        ) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== '0') {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports2.Command = Command2;
  },
});

// ../node_modules/commander/index.js
var require_commander = __commonJS({
  '../node_modules/commander/index.js'(exports2, module2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var {
      CommanderError: CommanderError2,
      InvalidArgumentError: InvalidArgumentError2,
    } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports2 = module2.exports = new Command2();
    exports2.program = exports2;
    exports2.Argument = Argument2;
    exports2.Command = Command2;
    exports2.CommanderError = CommanderError2;
    exports2.Help = Help2;
    exports2.InvalidArgumentError = InvalidArgumentError2;
    exports2.InvalidOptionArgumentError = InvalidArgumentError2;
    exports2.Option = Option2;
  },
});

// ../node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  '../node_modules/mimic-fn/index.js'(exports2, module2) {
    'use strict';
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(
          to,
          prop,
          Object.getOwnPropertyDescriptor(from, prop),
        );
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  },
});

// ../node_modules/onetime/index.js
var require_onetime = __commonJS({
  '../node_modules/onetime/index.js'(exports2, module2) {
    'use strict';
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime2 = (function_, options = {}) => {
      if (typeof function_ !== 'function') {
        throw new TypeError('Expected a function');
      }
      let returnValue;
      let callCount = 0;
      const functionName =
        function_.displayName || function_.name || '<anonymous>';
      const onetime3 = function (...arguments_) {
        calledFunctions.set(onetime3, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(
            `Function \`${functionName}\` can only be called once`,
          );
        }
        return returnValue;
      };
      mimicFn(onetime3, function_);
      calledFunctions.set(onetime3, callCount);
      return onetime3;
    };
    module2.exports = onetime2;
    module2.exports.default = onetime2;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(
          `The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`,
        );
      }
      return calledFunctions.get(function_);
    };
  },
});

// ../node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  '../node_modules/signal-exit/signals.js'(exports2, module2) {
    module2.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];
    if (process.platform !== 'win32') {
      module2.exports.push(
        'SIGVTALRM',
        'SIGXCPU',
        'SIGXFSZ',
        'SIGUSR2',
        'SIGTRAP',
        'SIGSYS',
        'SIGQUIT',
        'SIGIOT',
      );
    }
    if (process.platform === 'linux') {
      module2.exports.push(
        'SIGIO',
        'SIGPOLL',
        'SIGPWR',
        'SIGSTKFLT',
        'SIGUNUSED',
      );
    }
  },
});

// ../node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  '../node_modules/signal-exit/index.js'(exports2, module2) {
    var process9 = global.process;
    var processOk = function (process10) {
      return (
        process10 &&
        typeof process10 === 'object' &&
        typeof process10.removeListener === 'function' &&
        typeof process10.emit === 'function' &&
        typeof process10.reallyExit === 'function' &&
        typeof process10.listeners === 'function' &&
        typeof process10.kill === 'function' &&
        typeof process10.pid === 'number' &&
        typeof process10.on === 'function'
      );
    };
    if (!processOk(process9)) {
      module2.exports = function () {
        return function () {};
      };
    } else {
      assert = require('assert');
      signals = require_signals();
      isWin = /^win/i.test(process9.platform);
      EE = require('events');
      if (typeof EE !== 'function') {
        EE = EE.EventEmitter;
      }
      if (process9.__signal_exit_emitter__) {
        emitter = process9.__signal_exit_emitter__;
      } else {
        emitter = process9.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function (cb, opts) {
        if (!processOk(global.process)) {
          return function () {};
        }
        assert.equal(
          typeof cb,
          'function',
          'a callback must be provided for exit handler',
        );
        if (loaded === false) {
          load();
        }
        var ev = 'exit';
        if (opts && opts.alwaysLast) {
          ev = 'afterexit';
        }
        var remove = function () {
          emitter.removeListener(ev, cb);
          if (
            emitter.listeners('exit').length === 0 &&
            emitter.listeners('afterexit').length === 0
          ) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function (sig) {
          try {
            process9.removeListener(sig, sigListeners[sig]);
          } catch (er) {}
        });
        process9.emit = originalProcessEmit;
        process9.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function (sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process9.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit('exit', null, sig);
            emit('afterexit', null, sig);
            if (isWin && sig === 'SIGHUP') {
              sig = 'SIGINT';
            }
            process9.kill(process9.pid, sig);
          }
        };
      });
      module2.exports.signals = function () {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function (sig) {
          try {
            process9.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process9.emit = processEmit;
        process9.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process9.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process9.exitCode = code || 0;
        emit('exit', process9.exitCode, null);
        emit('afterexit', process9.exitCode, null);
        originalProcessReallyExit.call(process9, process9.exitCode);
      };
      originalProcessEmit = process9.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === 'exit' && processOk(global.process)) {
          if (arg !== void 0) {
            process9.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit('exit', process9.exitCode, null);
          emit('afterexit', process9.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  },
});

// ../node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  '../node_modules/cli-spinners/spinners.json'(exports2, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: [
          '\u280B',
          '\u2819',
          '\u2839',
          '\u2838',
          '\u283C',
          '\u2834',
          '\u2826',
          '\u2827',
          '\u2807',
          '\u280F',
        ],
      },
      dots2: {
        interval: 80,
        frames: [
          '\u28FE',
          '\u28FD',
          '\u28FB',
          '\u28BF',
          '\u287F',
          '\u28DF',
          '\u28EF',
          '\u28F7',
        ],
      },
      dots3: {
        interval: 80,
        frames: [
          '\u280B',
          '\u2819',
          '\u281A',
          '\u281E',
          '\u2816',
          '\u2826',
          '\u2834',
          '\u2832',
          '\u2833',
          '\u2813',
        ],
      },
      dots4: {
        interval: 80,
        frames: [
          '\u2804',
          '\u2806',
          '\u2807',
          '\u280B',
          '\u2819',
          '\u2838',
          '\u2830',
          '\u2820',
          '\u2830',
          '\u2838',
          '\u2819',
          '\u280B',
          '\u2807',
          '\u2806',
        ],
      },
      dots5: {
        interval: 80,
        frames: [
          '\u280B',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
        ],
      },
      dots6: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2809',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2824',
          '\u2804',
          '\u2804',
          '\u2824',
          '\u2834',
          '\u2832',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u281A',
          '\u2819',
          '\u2809',
          '\u2801',
        ],
      },
      dots7: {
        interval: 80,
        frames: [
          '\u2808',
          '\u2809',
          '\u280B',
          '\u2813',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2816',
          '\u2826',
          '\u2824',
          '\u2820',
          '\u2820',
          '\u2824',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
          '\u2809',
          '\u2808',
        ],
      },
      dots8: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2801',
          '\u2809',
          '\u2819',
          '\u281A',
          '\u2812',
          '\u2802',
          '\u2802',
          '\u2812',
          '\u2832',
          '\u2834',
          '\u2824',
          '\u2804',
          '\u2804',
          '\u2824',
          '\u2820',
          '\u2820',
          '\u2824',
          '\u2826',
          '\u2816',
          '\u2812',
          '\u2810',
          '\u2810',
          '\u2812',
          '\u2813',
          '\u280B',
          '\u2809',
          '\u2808',
          '\u2808',
        ],
      },
      dots9: {
        interval: 80,
        frames: [
          '\u28B9',
          '\u28BA',
          '\u28BC',
          '\u28F8',
          '\u28C7',
          '\u2867',
          '\u2857',
          '\u284F',
        ],
      },
      dots10: {
        interval: 80,
        frames: [
          '\u2884',
          '\u2882',
          '\u2881',
          '\u2841',
          '\u2848',
          '\u2850',
          '\u2860',
        ],
      },
      dots11: {
        interval: 100,
        frames: [
          '\u2801',
          '\u2802',
          '\u2804',
          '\u2840',
          '\u2880',
          '\u2820',
          '\u2810',
          '\u2808',
        ],
      },
      dots12: {
        interval: 80,
        frames: [
          '\u2880\u2800',
          '\u2840\u2800',
          '\u2804\u2800',
          '\u2882\u2800',
          '\u2842\u2800',
          '\u2805\u2800',
          '\u2883\u2800',
          '\u2843\u2800',
          '\u280D\u2800',
          '\u288B\u2800',
          '\u284B\u2800',
          '\u280D\u2801',
          '\u288B\u2801',
          '\u284B\u2801',
          '\u280D\u2809',
          '\u280B\u2809',
          '\u280B\u2809',
          '\u2809\u2819',
          '\u2809\u2819',
          '\u2809\u2829',
          '\u2808\u2899',
          '\u2808\u2859',
          '\u2888\u2829',
          '\u2840\u2899',
          '\u2804\u2859',
          '\u2882\u2829',
          '\u2842\u2898',
          '\u2805\u2858',
          '\u2883\u2828',
          '\u2843\u2890',
          '\u280D\u2850',
          '\u288B\u2820',
          '\u284B\u2880',
          '\u280D\u2841',
          '\u288B\u2801',
          '\u284B\u2801',
          '\u280D\u2809',
          '\u280B\u2809',
          '\u280B\u2809',
          '\u2809\u2819',
          '\u2809\u2819',
          '\u2809\u2829',
          '\u2808\u2899',
          '\u2808\u2859',
          '\u2808\u2829',
          '\u2800\u2899',
          '\u2800\u2859',
          '\u2800\u2829',
          '\u2800\u2898',
          '\u2800\u2858',
          '\u2800\u2828',
          '\u2800\u2890',
          '\u2800\u2850',
          '\u2800\u2820',
          '\u2800\u2880',
          '\u2800\u2840',
        ],
      },
      dots13: {
        interval: 80,
        frames: [
          '\u28FC',
          '\u28F9',
          '\u28BB',
          '\u283F',
          '\u285F',
          '\u28CF',
          '\u28E7',
          '\u28F6',
        ],
      },
      dots8Bit: {
        interval: 80,
        frames: [
          '\u2800',
          '\u2801',
          '\u2802',
          '\u2803',
          '\u2804',
          '\u2805',
          '\u2806',
          '\u2807',
          '\u2840',
          '\u2841',
          '\u2842',
          '\u2843',
          '\u2844',
          '\u2845',
          '\u2846',
          '\u2847',
          '\u2808',
          '\u2809',
          '\u280A',
          '\u280B',
          '\u280C',
          '\u280D',
          '\u280E',
          '\u280F',
          '\u2848',
          '\u2849',
          '\u284A',
          '\u284B',
          '\u284C',
          '\u284D',
          '\u284E',
          '\u284F',
          '\u2810',
          '\u2811',
          '\u2812',
          '\u2813',
          '\u2814',
          '\u2815',
          '\u2816',
          '\u2817',
          '\u2850',
          '\u2851',
          '\u2852',
          '\u2853',
          '\u2854',
          '\u2855',
          '\u2856',
          '\u2857',
          '\u2818',
          '\u2819',
          '\u281A',
          '\u281B',
          '\u281C',
          '\u281D',
          '\u281E',
          '\u281F',
          '\u2858',
          '\u2859',
          '\u285A',
          '\u285B',
          '\u285C',
          '\u285D',
          '\u285E',
          '\u285F',
          '\u2820',
          '\u2821',
          '\u2822',
          '\u2823',
          '\u2824',
          '\u2825',
          '\u2826',
          '\u2827',
          '\u2860',
          '\u2861',
          '\u2862',
          '\u2863',
          '\u2864',
          '\u2865',
          '\u2866',
          '\u2867',
          '\u2828',
          '\u2829',
          '\u282A',
          '\u282B',
          '\u282C',
          '\u282D',
          '\u282E',
          '\u282F',
          '\u2868',
          '\u2869',
          '\u286A',
          '\u286B',
          '\u286C',
          '\u286D',
          '\u286E',
          '\u286F',
          '\u2830',
          '\u2831',
          '\u2832',
          '\u2833',
          '\u2834',
          '\u2835',
          '\u2836',
          '\u2837',
          '\u2870',
          '\u2871',
          '\u2872',
          '\u2873',
          '\u2874',
          '\u2875',
          '\u2876',
          '\u2877',
          '\u2838',
          '\u2839',
          '\u283A',
          '\u283B',
          '\u283C',
          '\u283D',
          '\u283E',
          '\u283F',
          '\u2878',
          '\u2879',
          '\u287A',
          '\u287B',
          '\u287C',
          '\u287D',
          '\u287E',
          '\u287F',
          '\u2880',
          '\u2881',
          '\u2882',
          '\u2883',
          '\u2884',
          '\u2885',
          '\u2886',
          '\u2887',
          '\u28C0',
          '\u28C1',
          '\u28C2',
          '\u28C3',
          '\u28C4',
          '\u28C5',
          '\u28C6',
          '\u28C7',
          '\u2888',
          '\u2889',
          '\u288A',
          '\u288B',
          '\u288C',
          '\u288D',
          '\u288E',
          '\u288F',
          '\u28C8',
          '\u28C9',
          '\u28CA',
          '\u28CB',
          '\u28CC',
          '\u28CD',
          '\u28CE',
          '\u28CF',
          '\u2890',
          '\u2891',
          '\u2892',
          '\u2893',
          '\u2894',
          '\u2895',
          '\u2896',
          '\u2897',
          '\u28D0',
          '\u28D1',
          '\u28D2',
          '\u28D3',
          '\u28D4',
          '\u28D5',
          '\u28D6',
          '\u28D7',
          '\u2898',
          '\u2899',
          '\u289A',
          '\u289B',
          '\u289C',
          '\u289D',
          '\u289E',
          '\u289F',
          '\u28D8',
          '\u28D9',
          '\u28DA',
          '\u28DB',
          '\u28DC',
          '\u28DD',
          '\u28DE',
          '\u28DF',
          '\u28A0',
          '\u28A1',
          '\u28A2',
          '\u28A3',
          '\u28A4',
          '\u28A5',
          '\u28A6',
          '\u28A7',
          '\u28E0',
          '\u28E1',
          '\u28E2',
          '\u28E3',
          '\u28E4',
          '\u28E5',
          '\u28E6',
          '\u28E7',
          '\u28A8',
          '\u28A9',
          '\u28AA',
          '\u28AB',
          '\u28AC',
          '\u28AD',
          '\u28AE',
          '\u28AF',
          '\u28E8',
          '\u28E9',
          '\u28EA',
          '\u28EB',
          '\u28EC',
          '\u28ED',
          '\u28EE',
          '\u28EF',
          '\u28B0',
          '\u28B1',
          '\u28B2',
          '\u28B3',
          '\u28B4',
          '\u28B5',
          '\u28B6',
          '\u28B7',
          '\u28F0',
          '\u28F1',
          '\u28F2',
          '\u28F3',
          '\u28F4',
          '\u28F5',
          '\u28F6',
          '\u28F7',
          '\u28B8',
          '\u28B9',
          '\u28BA',
          '\u28BB',
          '\u28BC',
          '\u28BD',
          '\u28BE',
          '\u28BF',
          '\u28F8',
          '\u28F9',
          '\u28FA',
          '\u28FB',
          '\u28FC',
          '\u28FD',
          '\u28FE',
          '\u28FF',
        ],
      },
      sand: {
        interval: 80,
        frames: [
          '\u2801',
          '\u2802',
          '\u2804',
          '\u2840',
          '\u2848',
          '\u2850',
          '\u2860',
          '\u28C0',
          '\u28C1',
          '\u28C2',
          '\u28C4',
          '\u28CC',
          '\u28D4',
          '\u28E4',
          '\u28E5',
          '\u28E6',
          '\u28EE',
          '\u28F6',
          '\u28F7',
          '\u28FF',
          '\u287F',
          '\u283F',
          '\u289F',
          '\u281F',
          '\u285B',
          '\u281B',
          '\u282B',
          '\u288B',
          '\u280B',
          '\u280D',
          '\u2849',
          '\u2809',
          '\u2811',
          '\u2821',
          '\u2881',
        ],
      },
      line: {
        interval: 130,
        frames: ['-', '\\', '|', '/'],
      },
      line2: {
        interval: 100,
        frames: ['\u2802', '-', '\u2013', '\u2014', '\u2013', '-'],
      },
      pipe: {
        interval: 100,
        frames: [
          '\u2524',
          '\u2518',
          '\u2534',
          '\u2514',
          '\u251C',
          '\u250C',
          '\u252C',
          '\u2510',
        ],
      },
      simpleDots: {
        interval: 400,
        frames: ['.  ', '.. ', '...', '   '],
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: ['.  ', '.. ', '...', ' ..', '  .', '   '],
      },
      star: {
        interval: 70,
        frames: ['\u2736', '\u2738', '\u2739', '\u273A', '\u2739', '\u2737'],
      },
      star2: {
        interval: 80,
        frames: ['+', 'x', '*'],
      },
      flip: {
        interval: 70,
        frames: ['_', '_', '_', '-', '`', '`', "'", '\xB4', '-', '_', '_', '_'],
      },
      hamburger: {
        interval: 100,
        frames: ['\u2631', '\u2632', '\u2634'],
      },
      growVertical: {
        interval: 120,
        frames: [
          '\u2581',
          '\u2583',
          '\u2584',
          '\u2585',
          '\u2586',
          '\u2587',
          '\u2586',
          '\u2585',
          '\u2584',
          '\u2583',
        ],
      },
      growHorizontal: {
        interval: 120,
        frames: [
          '\u258F',
          '\u258E',
          '\u258D',
          '\u258C',
          '\u258B',
          '\u258A',
          '\u2589',
          '\u258A',
          '\u258B',
          '\u258C',
          '\u258D',
          '\u258E',
        ],
      },
      balloon: {
        interval: 140,
        frames: [' ', '.', 'o', 'O', '@', '*', ' '],
      },
      balloon2: {
        interval: 120,
        frames: ['.', 'o', 'O', '\xB0', 'O', 'o', '.'],
      },
      noise: {
        interval: 100,
        frames: ['\u2593', '\u2592', '\u2591'],
      },
      bounce: {
        interval: 120,
        frames: ['\u2801', '\u2802', '\u2804', '\u2802'],
      },
      boxBounce: {
        interval: 120,
        frames: ['\u2596', '\u2598', '\u259D', '\u2597'],
      },
      boxBounce2: {
        interval: 100,
        frames: ['\u258C', '\u2580', '\u2590', '\u2584'],
      },
      triangle: {
        interval: 50,
        frames: ['\u25E2', '\u25E3', '\u25E4', '\u25E5'],
      },
      arc: {
        interval: 100,
        frames: ['\u25DC', '\u25E0', '\u25DD', '\u25DE', '\u25E1', '\u25DF'],
      },
      circle: {
        interval: 120,
        frames: ['\u25E1', '\u2299', '\u25E0'],
      },
      squareCorners: {
        interval: 180,
        frames: ['\u25F0', '\u25F3', '\u25F2', '\u25F1'],
      },
      circleQuarters: {
        interval: 120,
        frames: ['\u25F4', '\u25F7', '\u25F6', '\u25F5'],
      },
      circleHalves: {
        interval: 50,
        frames: ['\u25D0', '\u25D3', '\u25D1', '\u25D2'],
      },
      squish: {
        interval: 100,
        frames: ['\u256B', '\u256A'],
      },
      toggle: {
        interval: 250,
        frames: ['\u22B6', '\u22B7'],
      },
      toggle2: {
        interval: 80,
        frames: ['\u25AB', '\u25AA'],
      },
      toggle3: {
        interval: 120,
        frames: ['\u25A1', '\u25A0'],
      },
      toggle4: {
        interval: 100,
        frames: ['\u25A0', '\u25A1', '\u25AA', '\u25AB'],
      },
      toggle5: {
        interval: 100,
        frames: ['\u25AE', '\u25AF'],
      },
      toggle6: {
        interval: 300,
        frames: ['\u101D', '\u1040'],
      },
      toggle7: {
        interval: 80,
        frames: ['\u29BE', '\u29BF'],
      },
      toggle8: {
        interval: 100,
        frames: ['\u25CD', '\u25CC'],
      },
      toggle9: {
        interval: 100,
        frames: ['\u25C9', '\u25CE'],
      },
      toggle10: {
        interval: 100,
        frames: ['\u3282', '\u3280', '\u3281'],
      },
      toggle11: {
        interval: 50,
        frames: ['\u29C7', '\u29C6'],
      },
      toggle12: {
        interval: 120,
        frames: ['\u2617', '\u2616'],
      },
      toggle13: {
        interval: 80,
        frames: ['=', '*', '-'],
      },
      arrow: {
        interval: 100,
        frames: [
          '\u2190',
          '\u2196',
          '\u2191',
          '\u2197',
          '\u2192',
          '\u2198',
          '\u2193',
          '\u2199',
        ],
      },
      arrow2: {
        interval: 80,
        frames: [
          '\u2B06\uFE0F ',
          '\u2197\uFE0F ',
          '\u27A1\uFE0F ',
          '\u2198\uFE0F ',
          '\u2B07\uFE0F ',
          '\u2199\uFE0F ',
          '\u2B05\uFE0F ',
          '\u2196\uFE0F ',
        ],
      },
      arrow3: {
        interval: 120,
        frames: [
          '\u25B9\u25B9\u25B9\u25B9\u25B9',
          '\u25B8\u25B9\u25B9\u25B9\u25B9',
          '\u25B9\u25B8\u25B9\u25B9\u25B9',
          '\u25B9\u25B9\u25B8\u25B9\u25B9',
          '\u25B9\u25B9\u25B9\u25B8\u25B9',
          '\u25B9\u25B9\u25B9\u25B9\u25B8',
        ],
      },
      bouncingBar: {
        interval: 80,
        frames: [
          '[    ]',
          '[=   ]',
          '[==  ]',
          '[=== ]',
          '[ ===]',
          '[  ==]',
          '[   =]',
          '[    ]',
          '[   =]',
          '[  ==]',
          '[ ===]',
          '[====]',
          '[=== ]',
          '[==  ]',
          '[=   ]',
        ],
      },
      bouncingBall: {
        interval: 80,
        frames: [
          '( \u25CF    )',
          '(  \u25CF   )',
          '(   \u25CF  )',
          '(    \u25CF )',
          '(     \u25CF)',
          '(    \u25CF )',
          '(   \u25CF  )',
          '(  \u25CF   )',
          '( \u25CF    )',
          '(\u25CF     )',
        ],
      },
      smiley: {
        interval: 200,
        frames: ['\u{1F604} ', '\u{1F61D} '],
      },
      monkey: {
        interval: 300,
        frames: ['\u{1F648} ', '\u{1F648} ', '\u{1F649} ', '\u{1F64A} '],
      },
      hearts: {
        interval: 100,
        frames: [
          '\u{1F49B} ',
          '\u{1F499} ',
          '\u{1F49C} ',
          '\u{1F49A} ',
          '\u2764\uFE0F ',
        ],
      },
      clock: {
        interval: 100,
        frames: [
          '\u{1F55B} ',
          '\u{1F550} ',
          '\u{1F551} ',
          '\u{1F552} ',
          '\u{1F553} ',
          '\u{1F554} ',
          '\u{1F555} ',
          '\u{1F556} ',
          '\u{1F557} ',
          '\u{1F558} ',
          '\u{1F559} ',
          '\u{1F55A} ',
        ],
      },
      earth: {
        interval: 180,
        frames: ['\u{1F30D} ', '\u{1F30E} ', '\u{1F30F} '],
      },
      material: {
        interval: 17,
        frames: [
          '\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
          '\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581',
        ],
      },
      moon: {
        interval: 80,
        frames: [
          '\u{1F311} ',
          '\u{1F312} ',
          '\u{1F313} ',
          '\u{1F314} ',
          '\u{1F315} ',
          '\u{1F316} ',
          '\u{1F317} ',
          '\u{1F318} ',
        ],
      },
      runner: {
        interval: 140,
        frames: ['\u{1F6B6} ', '\u{1F3C3} '],
      },
      pong: {
        interval: 80,
        frames: [
          '\u2590\u2802       \u258C',
          '\u2590\u2808       \u258C',
          '\u2590 \u2802      \u258C',
          '\u2590 \u2820      \u258C',
          '\u2590  \u2840     \u258C',
          '\u2590  \u2820     \u258C',
          '\u2590   \u2802    \u258C',
          '\u2590   \u2808    \u258C',
          '\u2590    \u2802   \u258C',
          '\u2590    \u2820   \u258C',
          '\u2590     \u2840  \u258C',
          '\u2590     \u2820  \u258C',
          '\u2590      \u2802 \u258C',
          '\u2590      \u2808 \u258C',
          '\u2590       \u2802\u258C',
          '\u2590       \u2820\u258C',
          '\u2590       \u2840\u258C',
          '\u2590      \u2820 \u258C',
          '\u2590      \u2802 \u258C',
          '\u2590     \u2808  \u258C',
          '\u2590     \u2802  \u258C',
          '\u2590    \u2820   \u258C',
          '\u2590    \u2840   \u258C',
          '\u2590   \u2820    \u258C',
          '\u2590   \u2802    \u258C',
          '\u2590  \u2808     \u258C',
          '\u2590  \u2802     \u258C',
          '\u2590 \u2820      \u258C',
          '\u2590 \u2840      \u258C',
          '\u2590\u2820       \u258C',
        ],
      },
      shark: {
        interval: 120,
        frames: [
          '\u2590|\\____________\u258C',
          '\u2590_|\\___________\u258C',
          '\u2590__|\\__________\u258C',
          '\u2590___|\\_________\u258C',
          '\u2590____|\\________\u258C',
          '\u2590_____|\\_______\u258C',
          '\u2590______|\\______\u258C',
          '\u2590_______|\\_____\u258C',
          '\u2590________|\\____\u258C',
          '\u2590_________|\\___\u258C',
          '\u2590__________|\\__\u258C',
          '\u2590___________|\\_\u258C',
          '\u2590____________|\\\u258C',
          '\u2590____________/|\u258C',
          '\u2590___________/|_\u258C',
          '\u2590__________/|__\u258C',
          '\u2590_________/|___\u258C',
          '\u2590________/|____\u258C',
          '\u2590_______/|_____\u258C',
          '\u2590______/|______\u258C',
          '\u2590_____/|_______\u258C',
          '\u2590____/|________\u258C',
          '\u2590___/|_________\u258C',
          '\u2590__/|__________\u258C',
          '\u2590_/|___________\u258C',
          '\u2590/|____________\u258C',
        ],
      },
      dqpb: {
        interval: 100,
        frames: ['d', 'q', 'p', 'b'],
      },
      weather: {
        interval: 100,
        frames: [
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
          '\u{1F324} ',
          '\u26C5\uFE0F ',
          '\u{1F325} ',
          '\u2601\uFE0F ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u26C8 ',
          '\u{1F328} ',
          '\u{1F327} ',
          '\u{1F328} ',
          '\u2601\uFE0F ',
          '\u{1F325} ',
          '\u26C5\uFE0F ',
          '\u{1F324} ',
          '\u2600\uFE0F ',
          '\u2600\uFE0F ',
        ],
      },
      christmas: {
        interval: 400,
        frames: ['\u{1F332}', '\u{1F384}'],
      },
      grenade: {
        interval: 80,
        frames: [
          '\u060C  ',
          '\u2032  ',
          ' \xB4 ',
          ' \u203E ',
          '  \u2E0C',
          '  \u2E0A',
          '  |',
          '  \u204E',
          '  \u2055',
          ' \u0DF4 ',
          '  \u2053',
          '   ',
          '   ',
          '   ',
        ],
      },
      point: {
        interval: 125,
        frames: [
          '\u2219\u2219\u2219',
          '\u25CF\u2219\u2219',
          '\u2219\u25CF\u2219',
          '\u2219\u2219\u25CF',
          '\u2219\u2219\u2219',
        ],
      },
      layer: {
        interval: 150,
        frames: ['-', '=', '\u2261'],
      },
      betaWave: {
        interval: 80,
        frames: [
          '\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2',
          '\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1',
        ],
      },
      fingerDance: {
        interval: 160,
        frames: [
          '\u{1F918} ',
          '\u{1F91F} ',
          '\u{1F596} ',
          '\u270B ',
          '\u{1F91A} ',
          '\u{1F446} ',
        ],
      },
      fistBump: {
        interval: 80,
        frames: [
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ',
          '\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ',
          '\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ',
          '\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ',
          '\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 ',
        ],
      },
      soccerHeader: {
        interval: 80,
        frames: [
          ' \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ',
          '\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ',
          '\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ',
          '\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ',
          '\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ',
          '\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ',
          '\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ',
          '\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ',
          '\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ',
          '\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ',
          '\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ',
          '\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ',
        ],
      },
      mindblown: {
        interval: 160,
        frames: [
          '\u{1F610} ',
          '\u{1F610} ',
          '\u{1F62E} ',
          '\u{1F62E} ',
          '\u{1F626} ',
          '\u{1F626} ',
          '\u{1F627} ',
          '\u{1F627} ',
          '\u{1F92F} ',
          '\u{1F4A5} ',
          '\u2728 ',
          '\u3000 ',
          '\u3000 ',
          '\u3000 ',
        ],
      },
      speaker: {
        interval: 160,
        frames: ['\u{1F508} ', '\u{1F509} ', '\u{1F50A} ', '\u{1F509} '],
      },
      orangePulse: {
        interval: 100,
        frames: [
          '\u{1F538} ',
          '\u{1F536} ',
          '\u{1F7E0} ',
          '\u{1F7E0} ',
          '\u{1F536} ',
        ],
      },
      bluePulse: {
        interval: 100,
        frames: [
          '\u{1F539} ',
          '\u{1F537} ',
          '\u{1F535} ',
          '\u{1F535} ',
          '\u{1F537} ',
        ],
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          '\u{1F538} ',
          '\u{1F536} ',
          '\u{1F7E0} ',
          '\u{1F7E0} ',
          '\u{1F536} ',
          '\u{1F539} ',
          '\u{1F537} ',
          '\u{1F535} ',
          '\u{1F535} ',
          '\u{1F537} ',
        ],
      },
      timeTravel: {
        interval: 100,
        frames: [
          '\u{1F55B} ',
          '\u{1F55A} ',
          '\u{1F559} ',
          '\u{1F558} ',
          '\u{1F557} ',
          '\u{1F556} ',
          '\u{1F555} ',
          '\u{1F554} ',
          '\u{1F553} ',
          '\u{1F552} ',
          '\u{1F551} ',
          '\u{1F550} ',
        ],
      },
      aesthetic: {
        interval: 80,
        frames: [
          '\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1',
          '\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0',
          '\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1',
        ],
      },
    };
  },
});

// ../node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  '../node_modules/cli-spinners/index.js'(exports2, module2) {
    'use strict';
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, 'random', {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      },
    });
    module2.exports = spinners;
  },
});

// ../node_modules/clone/clone.js
var require_clone = __commonJS({
  '../node_modules/clone/clone.js'(exports2, module2) {
    var clone = (function () {
      'use strict';
      function clone2(parent, circular, depth, prototype) {
        var filter;
        if (typeof circular === 'object') {
          depth = circular.depth;
          prototype = circular.prototype;
          filter = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != 'undefined';
        if (typeof circular == 'undefined') circular = true;
        if (typeof depth == 'undefined') depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null) return null;
          if (depth2 == 0) return parent2;
          var child;
          var proto3;
          if (typeof parent2 != 'object') {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype == 'undefined') {
              proto3 = Object.getPrototypeOf(parent2);
              child = Object.create(proto3);
            } else {
              child = Object.create(prototype);
              proto3 = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i in parent2) {
            var attrs;
            if (proto3) {
              attrs = Object.getOwnPropertyDescriptor(proto3, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null) return null;
        var c = function () {};
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Date]';
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === 'object' && __objToStr(o) === '[object Array]';
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = '';
        if (re.global) flags += 'g';
        if (re.ignoreCase) flags += 'i';
        if (re.multiline) flags += 'm';
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    })();
    if (typeof module2 === 'object' && module2.exports) {
      module2.exports = clone;
    }
  },
});

// ../node_modules/defaults/index.js
var require_defaults = __commonJS({
  '../node_modules/defaults/index.js'(exports2, module2) {
    var clone = require_clone();
    module2.exports = function (options, defaults) {
      options = options || {};
      Object.keys(defaults).forEach(function (key) {
        if (typeof options[key] === 'undefined') {
          options[key] = clone(defaults[key]);
        }
      });
      return options;
    };
  },
});

// ../node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  '../node_modules/wcwidth/combining.js'(exports2, module2) {
    module2.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999],
    ];
  },
});

// ../node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  '../node_modules/wcwidth/index.js'(exports2, module2) {
    'use strict';
    var defaults = require_defaults();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0,
    };
    module2.exports = function wcwidth3(str) {
      return wcswidth(str, DEFAULTS);
    };
    module2.exports.config = function (opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth3(str) {
        return wcswidth(str, opts);
      };
    };
    function wcswidth(str, opts) {
      if (typeof str !== 'string') return wcwidth2(str, opts);
      var s = 0;
      for (var i = 0; i < str.length; i++) {
        var n = wcwidth2(str.charCodeAt(i), opts);
        if (n < 0) return -1;
        s += n;
      }
      return s;
    }
    function wcwidth2(ucs, opts) {
      if (ucs === 0) return opts.nul;
      if (ucs < 32 || (ucs >= 127 && ucs < 160)) return opts.control;
      if (bisearch(ucs)) return 0;
      return (
        1 +
        (ucs >= 4352 &&
          (ucs <= 4447 ||
            ucs == 9001 ||
            ucs == 9002 ||
            (ucs >= 11904 && ucs <= 42191 && ucs != 12351) ||
            (ucs >= 44032 && ucs <= 55203) ||
            (ucs >= 63744 && ucs <= 64255) ||
            (ucs >= 65040 && ucs <= 65049) ||
            (ucs >= 65072 && ucs <= 65135) ||
            (ucs >= 65280 && ucs <= 65376) ||
            (ucs >= 65504 && ucs <= 65510) ||
            (ucs >= 131072 && ucs <= 196605) ||
            (ucs >= 196608 && ucs <= 262141)))
      );
    }
    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1]) return false;
      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1]) min = mid + 1;
        else if (ucs < combining[mid][0]) max = mid - 1;
        else return true;
      }
      return false;
    }
  },
});

// ../node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/stream.js'(
    exports2,
    module2,
  ) {
    module2.exports = require('stream');
  },
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/buffer_list.js'(
    exports2,
    module2,
  ) {
    'use strict';
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source),
          );
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key),
            );
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true,
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require('buffer');
    var Buffer2 = _require.Buffer;
    var _require2 = require('util');
    var inspect = _require2.inspect;
    var custom = (inspect && inspect.custom) || 'inspect';
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ (function () {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [
        {
          key: 'push',
          value: function push(v) {
            var entry = {
              data: v,
              next: null,
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          },
        },
        {
          key: 'unshift',
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head,
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          },
        },
        {
          key: 'shift',
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          },
        },
        {
          key: 'clear',
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          },
        },
        {
          key: 'join',
          value: function join(s) {
            if (this.length === 0) return '';
            var p = this.head;
            var ret = '' + p.data;
            while ((p = p.next)) {
              ret += s + p.data;
            }
            return ret;
          },
        },
        {
          key: 'concat',
          value: function concat(n) {
            if (this.length === 0) return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          },
        },
        {
          key: 'consume',
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          },
        },
        {
          key: 'first',
          value: function first() {
            return this.head.data;
          },
        },
        {
          key: '_getString',
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while ((p = p.next)) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          },
        },
        {
          key: '_getBuffer',
          value: function _getBuffer(n) {
            var ret = Buffer2.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while ((p = p.next)) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          },
        },
        {
          key: custom,
          value: function value(_, options) {
            return inspect(
              this,
              _objectSpread({}, options, {
                depth: 0,
                customInspect: false,
              }),
            );
          },
        },
      ]);
      return BufferList;
    })();
  },
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/destroy.js'(
    exports2,
    module2,
  ) {
    'use strict';
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed =
        this._readableState && this._readableState.destroyed;
      var writableDestroyed =
        this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function (err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self, err) {
      emitErrorNT(self, err);
      emitCloseNT(self);
    }
    function emitCloseNT(self) {
      if (self._writableState && !self._writableState.emitClose) return;
      if (self._readableState && !self._readableState.emitClose) return;
      self.emit('close');
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self, err) {
      self.emit('error', err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if ((rState && rState.autoDestroy) || (wState && wState.autoDestroy))
        stream.destroy(err);
      else stream.emit('error', err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy,
    };
  },
});

// ../node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  '../node_modules/readable-stream/errors.js'(exports2, module2) {
    'use strict';
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return (
            `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
            expected[len - 1]
          );
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType(
      'ERR_INVALID_OPT_VALUE',
      function (name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      },
      TypeError,
    );
    createErrorType(
      'ERR_INVALID_ARG_TYPE',
      function (name, expected, actual) {
        let determiner;
        if (typeof expected === 'string' && startsWith(expected, 'not ')) {
          determiner = 'must not be';
          expected = expected.replace(/^not /, '');
        } else {
          determiner = 'must be';
        }
        let msg;
        if (endsWith(name, ' argument')) {
          msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
        } else {
          const type = includes(name, '.') ? 'property' : 'argument';
          msg = `The "${name}" ${type} ${determiner} ${oneOf(
            expected,
            'type',
          )}`;
        }
        msg += `. Received type ${typeof actual}`;
        return msg;
      },
      TypeError,
    );
    createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
    createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
      return 'The ' + name + ' method is not implemented';
    });
    createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
    createErrorType('ERR_STREAM_DESTROYED', function (name) {
      return 'Cannot call ' + name + ' after a stream was destroyed';
    });
    createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
    createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
    createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    createErrorType(
      'ERR_STREAM_NULL_VALUES',
      'May not write null values to stream',
      TypeError,
    );
    createErrorType(
      'ERR_UNKNOWN_ENCODING',
      function (arg) {
        return 'Unknown encoding: ' + arg;
      },
      TypeError,
    );
    createErrorType(
      'ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
      'stream.unshift() after end event',
    );
    module2.exports.codes = codes;
  },
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/state.js'(
    exports2,
    module2,
  ) {
    'use strict';
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null
        ? options.highWaterMark
        : isDuplex
        ? options[duplexKey]
        : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : 'highWaterMark';
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark,
    };
  },
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  '../node_modules/inherits/inherits_browser.js'(exports2, module2) {
    if (typeof Object.create === 'function') {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true,
            },
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  },
});

// ../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  '../node_modules/inherits/inherits.js'(exports2, module2) {
    try {
      util = require('util');
      if (typeof util.inherits !== 'function') throw '';
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  },
});

// ../node_modules/util-deprecate/node.js
var require_node = __commonJS({
  '../node_modules/util-deprecate/node.js'(exports2, module2) {
    module2.exports = require('util').deprecate;
  },
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  '../node_modules/readable-stream/lib/_stream_writable.js'(exports2, module2) {
    'use strict';
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function () {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node(),
    };
    var Stream = require_stream();
    var Buffer2 = require('buffer').Buffer;
    var OurUint8Array = global.Uint8Array || function () {};
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {}
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(
        this,
        options,
        'writableHighWaterMark',
        isDuplex,
      );
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function (er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function () {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
          get: internalUtil.deprecate(
            function writableStateBufferGetter() {
              return this.getBuffer();
            },
            '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
            'DEP0003',
          ),
        });
      } catch (_) {}
    })();
    var realHasInstance;
    if (
      typeof Symbol === 'function' &&
      Symbol.hasInstance &&
      typeof Function.prototype[Symbol.hasInstance] === 'function'
    ) {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        },
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
        if (typeof options.destroy === 'function')
          this._destroy = options.destroy;
        if (typeof options.final === 'function') this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function () {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== 'string' && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = 'buffer';
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== 'function') cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function () {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function () {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (
          !state.writing &&
          !state.corked &&
          !state.bufferProcessing &&
          state.bufferedRequest
        )
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
      encoding,
    ) {
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (
        !(
          [
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw',
          ].indexOf((encoding + '').toLowerCase()) > -1
        )
      )
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, 'writableBuffer', {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      },
    });
    function decodeChunk(state, chunk, encoding) {
      if (
        !state.objectMode &&
        state.decodeStrings !== false &&
        typeof chunk === 'string'
      ) {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      },
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = 'buffer';
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null,
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (
          !finished &&
          !state.corked &&
          !state.bufferProcessing &&
          state.bufferedRequest
        ) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, 'writableLength', {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      },
    });
    function needFinish(state) {
      return (
        state.ending &&
        state.length === 0 &&
        state.bufferedRequest === null &&
        !state.finished &&
        !state.writing
      );
    }
    function callFinal(stream, state) {
      stream._final(function (err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit('prefinish');
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit('finish');
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || (rState.autoDestroy && rState.endEmitted)) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, 'destroyed', {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      },
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function (err, cb) {
      cb(err);
    };
  },
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  '../node_modules/readable-stream/lib/_stream_duplex.js'(exports2, module2) {
    'use strict';
    var objectKeys =
      Object.keys ||
      function (obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once('end', onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      },
    });
    Object.defineProperty(Duplex.prototype, 'writableBuffer', {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      },
    });
    Object.defineProperty(Duplex.prototype, 'writableLength', {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      },
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    Object.defineProperty(Duplex.prototype, 'destroyed', {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      },
    });
  },
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  '../node_modules/safe-buffer/index.js'(exports2, module2) {
    var buffer = require('buffer');
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (
      Buffer2.from &&
      Buffer2.alloc &&
      Buffer2.allocUnsafe &&
      Buffer2.allocUnsafeSlow
    ) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }
      return buffer.SlowBuffer(size);
    };
  },
});

// ../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  '../node_modules/string_decoder/lib/string_decoder.js'(exports2) {
    'use strict';
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding =
      Buffer2.isEncoding ||
      function (encoding) {
        encoding = '' + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return true;
          default:
            return false;
        }
      };
    function _normalizeEncoding(enc) {
      if (!enc) return 'utf8';
      var retried;
      while (true) {
        switch (enc) {
          case 'utf8':
          case 'utf-8':
            return 'utf8';
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return 'utf16le';
          case 'latin1':
          case 'binary':
            return 'latin1';
          case 'base64':
          case 'ascii':
          case 'hex':
            return enc;
          default:
            if (retried) return;
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (
        typeof nenc !== 'string' &&
        (Buffer2.isEncoding === isEncoding || !isEncoding(enc))
      )
        throw new Error('Unknown encoding: ' + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case 'utf16le':
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case 'utf8':
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case 'base64':
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function (buf) {
      if (buf.length === 0) return '';
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || '';
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function (buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(
          this.lastChar,
          this.lastTotal - this.lastNeed,
          0,
          this.lastNeed,
        );
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return '\uFFFD';
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return '\uFFFD';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return '\uFFFD';
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString('utf8', i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString('utf8', i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + '\uFFFD';
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString('utf16le', i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString('base64', i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString('base64', i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed)
        return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : '';
    }
  },
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/end-of-stream.js'(
    exports2,
    module2,
  ) {
    'use strict';
    var ERR_STREAM_PREMATURE_CLOSE =
      require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {}
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }
    function eos(stream, opts, callback) {
      if (typeof opts === 'function') return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable =
        opts.readable || (opts.readable !== false && stream.readable);
      var writable =
        opts.writable || (opts.writable !== false && stream.writable);
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded =
        stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded =
        stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on('finish', onfinish);
      };
      if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
      } else if (writable && !stream._writableState) {
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
      }
      stream.on('end', onend);
      stream.on('finish', onfinish);
      if (opts.error !== false) stream.on('error', onerror);
      stream.on('close', onclose);
      return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
      };
    }
    module2.exports = eos;
  },
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/async_iterator.js'(
    exports2,
    module2,
  ) {
    'use strict';
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true,
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol('lastResolve');
    var kLastReject = Symbol('lastReject');
    var kError = Symbol('error');
    var kEnded = Symbol('ended');
    var kLastPromise = Symbol('lastPromise');
    var kHandlePromise = Symbol('handlePromise');
    var kStream = Symbol('stream');
    function createIterResult(value, done) {
      return {
        value,
        done,
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function (resolve, reject) {
        lastPromise.then(function () {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(
      ((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function (resolve, reject) {
              process.nextTick(function () {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        },
      }),
      _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
        return this;
      }),
      _defineProperty(_Object$setPrototypeO, 'return', function _return() {
        var _this2 = this;
        return new Promise(function (resolve, reject) {
          _this2[kStream].destroy(null, function (err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }),
      _Object$setPrototypeO),
      AsyncIteratorPrototype,
    );
    var createReadableStreamAsyncIterator =
      function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(
          ReadableStreamAsyncIteratorPrototype,
          ((_Object$create = {}),
          _defineProperty(_Object$create, kStream, {
            value: stream,
            writable: true,
          }),
          _defineProperty(_Object$create, kLastResolve, {
            value: null,
            writable: true,
          }),
          _defineProperty(_Object$create, kLastReject, {
            value: null,
            writable: true,
          }),
          _defineProperty(_Object$create, kError, {
            value: null,
            writable: true,
          }),
          _defineProperty(_Object$create, kEnded, {
            value: stream._readableState.endEmitted,
            writable: true,
          }),
          _defineProperty(_Object$create, kHandlePromise, {
            value: function value(resolve, reject) {
              var data = iterator[kStream].read();
              if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
              } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
              }
            },
            writable: true,
          }),
          _Object$create),
        );
        iterator[kLastPromise] = null;
        finished(stream, function (err) {
          if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on('readable', onReadable.bind(null, iterator));
        return iterator;
      };
    module2.exports = createReadableStreamAsyncIterator;
  },
});

// ../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/from.js'(
    exports2,
    module2,
  ) {
    'use strict';
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
          args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(
              gen,
              resolve,
              reject,
              _next,
              _throw,
              'next',
              value,
            );
          }
          function _throw(err) {
            asyncGeneratorStep(
              gen,
              resolve,
              reject,
              _next,
              _throw,
              'throw',
              err,
            );
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source),
          );
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key),
            );
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true,
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === 'function') {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
      var readable = new Readable(
        _objectSpread(
          {
            objectMode: true,
          },
          opts,
        ),
      );
      var reading = false;
      readable._read = function () {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(),
              value = _ref.value,
              done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  },
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  '../node_modules/readable-stream/lib/_stream_readable.js'(exports2, module2) {
    'use strict';
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require('events').EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require('buffer').Buffer;
    var OurUint8Array = global.Uint8Array || function () {};
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require('util');
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog('stream');
    } else {
      debug = function debug2() {};
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT =
      _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === 'function')
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(
        this,
        options,
        'readableHighWaterMark',
        isDuplex,
      );
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === 'function') this._read = options.read;
        if (typeof options.destroy === 'function')
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, 'destroyed', {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      },
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function (err, cb) {
      cb(err);
    };
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === 'string') {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = '';
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function (chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(
      stream,
      chunk,
      encoding,
      addToFront,
      skipChunkCheck,
    ) {
      debug('readableAddChunk', chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || (chunk && chunk.length > 0)) {
          if (
            typeof chunk !== 'string' &&
            !state.objectMode &&
            Object.getPrototypeOf(chunk) !== Buffer2.prototype
          ) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return (
        !state.ended &&
        (state.length < state.highWaterMark || state.length === 0)
      );
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (
        !_isUint8Array(chunk) &&
        typeof chunk !== 'string' &&
        chunk !== void 0 &&
        !state.objectMode
      ) {
        er = new ERR_INVALID_ARG_TYPE(
          'chunk',
          ['string', 'Buffer', 'Uint8Array'],
          chunk,
        );
      }
      return er;
    }
    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = '';
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== '') this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || (state.length === 0 && state.ended)) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function (n) {
      debug('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (
        n === 0 &&
        state.needReadable &&
        ((state.highWaterMark !== 0
          ? state.length >= state.highWaterMark
          : state.length > 0) ||
          state.ended)
      ) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit('data', ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug('onEofChunk');
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug('emitReadable', state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug('emitReadable_', state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
      }
      state.needReadable =
        !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (
        !state.reading &&
        !state.ended &&
        (state.length < state.highWaterMark ||
          (state.flowing && state.length === 0))
      ) {
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function (n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
    };
    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd =
        (!pipeOpts || pipeOpts.end !== false) &&
        dest !== process.stdout &&
        dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true;
        if (
          state.awaitDrain &&
          (!dest._writableState || dest._writableState.needDrain)
        )
          ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);
        if (ret === false) {
          if (
            ((state.pipesCount === 1 && state.pipes === dest) ||
              (state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1)) &&
            !cleanedUp
          ) {
            debug('false write response, pause', state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, 'error', onerror);
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false,
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit('unpipe', this, {
            hasUnpiped: false,
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function (ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === 'data') {
        state.readableListening = this.listenerCount('readable') > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug('on readable', state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function (ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === 'readable') {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function (ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === 'readable' || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self) {
      var state = self._readableState;
      state.readableListening = self.listenerCount('readable') > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self.listenerCount('data') > 0) {
        self.resume();
      }
    }
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug('resume', state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }
    Readable.prototype.wrap = function (stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === 'function') {
          this[i] = (function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function (n2) {
        debug('wrapped _read', n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === 'function') {
      Readable.prototype[Symbol.asyncIterator] = function () {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      },
    });
    Object.defineProperty(Readable.prototype, 'readableBuffer', {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      },
    });
    Object.defineProperty(Readable.prototype, 'readableFlowing', {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      },
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, 'readableLength', {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      },
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join('');
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug('endReadable', state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug('endReadableNT', state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || (wState.autoDestroy && wState.finished)) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === 'function') {
      Readable.from = function (iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  },
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  '../node_modules/readable-stream/lib/_stream_transform.js'(
    exports2,
    module2,
  ) {
    'use strict';
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING =
      _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 =
      _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null) this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null,
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      }
      this.on('prefinish', prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
    };
    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function (n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function (err, cb) {
      Duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit('error', er);
      if (data != null) stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  },
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  '../node_modules/readable-stream/lib/_stream_passthrough.js'(
    exports2,
    module2,
  ) {
    'use strict';
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };
  },
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  '../node_modules/readable-stream/lib/internal/streams/pipeline.js'(
    exports2,
    module2,
  ) {
    'use strict';
    var eos;
    function once(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on('close', function () {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(
        stream,
        {
          readable: reading,
          writable: writing,
        },
        function (err) {
          if (err) return callback(err);
          closed = true;
          callback();
        },
      );
      var destroyed = false;
      return function (err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== 'function') return noop;
      return streams.pop();
    }
    function pipeline() {
      for (
        var _len = arguments.length, streams = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
      }
      var error;
      var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  },
});

// ../node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  '../node_modules/readable-stream/readable.js'(exports2, module2) {
    var Stream = require('stream');
    if (process.env.READABLE_STREAM === 'disable' && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  },
});

// ../node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  '../node_modules/bl/BufferList.js'(exports2, module2) {
    'use strict';
    var { Buffer: Buffer2 } = require('buffer');
    var symbol = Symbol.for('BufferList');
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function (blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === 'number' && start < 0) {
        start += this.length;
      }
      if (typeof end === 'number' && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== 'number' || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== 'number' || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = (copy2 && dstStart) || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1
            ? this._bufs[0]
            : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2
          ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
          : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff) return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== 'number' ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(
          0,
          endOffset[1],
        );
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(
          Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength),
        );
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === 'number') {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function (search, offset, encoding) {
      if (encoding === void 0 && typeof offset === 'string') {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === 'function' || Array.isArray(search)) {
        throw new TypeError(
          'The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.',
        );
      } else if (typeof search === 'number') {
        search = Buffer2.from([search]);
      } else if (typeof search === 'string') {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(
          search.buffer,
          search.byteOffset,
          search.byteLength,
        );
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function (offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function () {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null,
      };
      for (const m in methods) {
        (function (m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function (offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function (offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  },
});

// ../node_modules/bl/bl.js
var require_bl = __commonJS({
  '../node_modules/bl/bl.js'(exports2, module2) {
    'use strict';
    var DuplexStream = require_readable().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream2(callback) {
      if (!(this instanceof BufferListStream2)) {
        return new BufferListStream2(callback);
      }
      if (typeof callback === 'function') {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on('pipe', function onPipe(src) {
          src.on('error', piper);
        });
        this.on('unpipe', function onUnpipe(src) {
          src.removeListener('error', piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream2, DuplexStream);
    Object.assign(BufferListStream2.prototype, BufferList.prototype);
    BufferListStream2.prototype._new = function _new(callback) {
      return new BufferListStream2(callback);
    };
    BufferListStream2.prototype._write = function _write(
      buf,
      encoding,
      callback,
    ) {
      this._appendBuffer(buf);
      if (typeof callback === 'function') {
        callback();
      }
    };
    BufferListStream2.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream2.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream2.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream2.prototype._isBufferList = function _isBufferList(b) {
      return (
        b instanceof BufferListStream2 ||
        b instanceof BufferList ||
        BufferListStream2.isBufferList(b)
      );
    };
    BufferListStream2.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream2;
    module2.exports.BufferListStream = BufferListStream2;
    module2.exports.BufferList = BufferList;
  },
});

// ../node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help,
} = import_index.default;

// src/index.ts
var fs = __toESM(require('fs'));

// ../node_modules/ora/index.js
var import_node_process7 = __toESM(require('node:process'), 1);

// ../node_modules/ora/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 =
  (offset = 0) =>
  (code) =>
    `\x1B[${code + offset}m`;
var wrapAnsi256 =
  (offset = 0) =>
  (code) =>
    `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m =
  (offset = 0) =>
  (red, green, blue) =>
    `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`,
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false,
    });
  }
  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false,
  });
  styles.color.close = '\x1B[39m';
  styles.bgColor.close = '\x1B[49m';
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round(((red - 8) / 247) * 24) + 232;
        }
        return (
          16 +
          36 * Math.round((red / 255) * 5) +
          6 * Math.round((green / 255) * 5) +
          Math.round((blue / 255) * 5)
        );
      },
      enumerable: false,
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString]
            .map((character) => character + character)
            .join('');
        }
        const integer = Number.parseInt(colorString, 16);
        return [(integer >> 16) & 255, (integer >> 8) & 255, integer & 255];
      },
      enumerable: false,
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false,
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = (remainder % 6) / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result =
          30 +
          ((Math.round(blue) << 2) |
            (Math.round(green) << 1) |
            Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false,
    },
    rgbToAnsi: {
      value: (red, green, blue) =>
        styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false,
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false,
    },
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../node_modules/ora/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require('node:process'), 1);
var import_node_os = __toESM(require('node:os'), 1);
var import_node_tty = __toESM(require('node:tty'), 1);
function hasFlag(flag, argv = import_node_process.default.argv) {
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return (
    position !== -1 &&
    (terminatorPosition === -1 || position < terminatorPosition)
  );
}
var { env } = import_node_process.default;
var flagForceColor;
if (
  hasFlag('no-color') ||
  hasFlag('no-colors') ||
  hasFlag('color=false') ||
  hasFlag('color=never')
) {
  flagForceColor = 0;
} else if (
  hasFlag('color') ||
  hasFlag('colors') ||
  hasFlag('color=true') ||
  hasFlag('color=always')
) {
  flagForceColor = 1;
}
function envForceColor() {
  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      return 1;
    }
    if (env.FORCE_COLOR === 'false') {
      return 0;
    }
    return env.FORCE_COLOR.length === 0
      ? 1
      : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (
      hasFlag('color=16m') ||
      hasFlag('color=full') ||
      hasFlag('color=truecolor')
    ) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === 'dumb') {
    return min;
  }
  if (import_node_process.default.platform === 'win32') {
    const osRelease = import_node_os.default.release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ('CI' in env) {
    if (
      [
        'TRAVIS',
        'CIRCLECI',
        'APPVEYOR',
        'GITLAB_CI',
        'GITHUB_ACTIONS',
        'BUILDKITE',
        'DRONE',
      ].some((sign) => sign in env) ||
      env.CI_NAME === 'codeship'
    ) {
      return 1;
    }
    return min;
  }
  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
    return 1;
  }
  if (env.COLORTERM === 'truecolor') {
    return 3;
  }
  if ('TERM_PROGRAM' in env) {
    const version = Number.parseInt(
      (env.TERM_PROGRAM_VERSION || '').split('.')[0],
      10,
    );
    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Apple_Terminal':
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (
    /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)
  ) {
    return 1;
  }
  if ('COLORTERM' in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options,
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) }),
};
var supports_color_default = supportsColor;

// ../node_modules/ora/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = '';
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = '';
  do {
    const gotCR = string[index - 1] === '\r';
    returnValue +=
      string.slice(endIndex, gotCR ? index - 1 : index) +
      prefix +
      (gotCR ? '\r\n' : '\n') +
      postfix;
    endIndex = index + 1;
    index = string.indexOf('\n', endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../node_modules/ora/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol('GENERATOR');
var STYLER = Symbol('STYLER');
var IS_EMPTY = Symbol('IS_EMPTY');
var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (
    options.level &&
    !(
      Number.isInteger(options.level) &&
      options.level >= 0 &&
      options.level <= 3
    )
  ) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk3 = (...strings) => strings.join(' ');
  applyOptions(chalk3, options);
  Object.setPrototypeOf(chalk3, createChalk.prototype);
  return chalk3;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(
        this,
        createStyler(style.open, style.close, this[STYLER]),
        this[IS_EMPTY],
      );
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    },
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, 'visible', { value: builder });
    return builder;
  },
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === 'rgb') {
    if (level === 'ansi16m') {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === 'ansi256') {
      return ansi_styles_default[type].ansi256(
        ansi_styles_default.rgbToAnsi256(...arguments_),
      );
    }
    return ansi_styles_default[type].ansi(
      ansi_styles_default.rgbToAnsi(...arguments_),
    );
  }
  if (model === 'hex') {
    return getModelAnsi(
      'rgb',
      level,
      type,
      ...ansi_styles_default.hexToRgb(...arguments_),
    );
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ['rgb', 'hex', 'ansi256'];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          getModelAnsi(model, levelMapping[level], 'color', ...arguments_),
          ansi_styles_default.color.close,
          this[STYLER],
        );
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    },
  };
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler(
          getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_),
          ansi_styles_default.bgColor.close,
          this[STYLER],
        );
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    },
  };
}
var proto = Object.defineProperties(() => {}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    },
  },
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent,
  };
};
var createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) =>
    applyStyle(
      builder,
      arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '),
    );
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? '' : string;
  }
  let styler = self[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes('\x1B')) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// ../node_modules/cli-cursor/index.js
var import_node_process3 = __toESM(require('node:process'), 1);

// ../node_modules/restore-cursor/index.js
var import_node_process2 = __toESM(require('node:process'), 1);
var import_onetime = __toESM(require_onetime(), 1);
var import_signal_exit = __toESM(require_signal_exit(), 1);
var restoreCursor = (0, import_onetime.default)(() => {
  (0, import_signal_exit.default)(
    () => {
      import_node_process2.default.stderr.write('\x1B[?25h');
    },
    { alwaysLast: true },
  );
});
var restore_cursor_default = restoreCursor;

// ../node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write('\x1B[?25h');
};
cliCursor.hide = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write('\x1B[?25l');
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== void 0) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// ../node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners(), 1);

// ../node_modules/log-symbols/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET2 = 10;
var wrapAnsi162 =
  (offset = 0) =>
  (code) =>
    `\x1B[${code + offset}m`;
var wrapAnsi2562 =
  (offset = 0) =>
  (code) =>
    `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m2 =
  (offset = 0) =>
  (red, green, blue) =>
    `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles3 = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39],
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49],
  },
};
var modifierNames2 = Object.keys(styles3.modifier);
var foregroundColorNames2 = Object.keys(styles3.color);
var backgroundColorNames2 = Object.keys(styles3.bgColor);
var colorNames2 = [...foregroundColorNames2, ...backgroundColorNames2];
function assembleStyles2() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles3)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles3[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`,
      };
      group[styleName] = styles3[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles3, groupName, {
      value: group,
      enumerable: false,
    });
  }
  Object.defineProperty(styles3, 'codes', {
    value: codes,
    enumerable: false,
  });
  styles3.color.close = '\x1B[39m';
  styles3.bgColor.close = '\x1B[49m';
  styles3.color.ansi = wrapAnsi162();
  styles3.color.ansi256 = wrapAnsi2562();
  styles3.color.ansi16m = wrapAnsi16m2();
  styles3.bgColor.ansi = wrapAnsi162(ANSI_BACKGROUND_OFFSET2);
  styles3.bgColor.ansi256 = wrapAnsi2562(ANSI_BACKGROUND_OFFSET2);
  styles3.bgColor.ansi16m = wrapAnsi16m2(ANSI_BACKGROUND_OFFSET2);
  Object.defineProperties(styles3, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round(((red - 8) / 247) * 24) + 232;
        }
        return (
          16 +
          36 * Math.round((red / 255) * 5) +
          6 * Math.round((green / 255) * 5) +
          Math.round((blue / 255) * 5)
        );
      },
      enumerable: false,
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString]
            .map((character) => character + character)
            .join('');
        }
        const integer = Number.parseInt(colorString, 16);
        return [(integer >> 16) & 255, (integer >> 8) & 255, integer & 255];
      },
      enumerable: false,
    },
    hexToAnsi256: {
      value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
      enumerable: false,
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = (remainder % 6) / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result =
          30 +
          ((Math.round(blue) << 2) |
            (Math.round(green) << 1) |
            Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false,
    },
    rgbToAnsi: {
      value: (red, green, blue) =>
        styles3.ansi256ToAnsi(styles3.rgbToAnsi256(red, green, blue)),
      enumerable: false,
    },
    hexToAnsi: {
      value: (hex) => styles3.ansi256ToAnsi(styles3.hexToAnsi256(hex)),
      enumerable: false,
    },
  });
  return styles3;
}
var ansiStyles2 = assembleStyles2();
var ansi_styles_default2 = ansiStyles2;

// ../node_modules/log-symbols/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process4 = __toESM(require('node:process'), 1);
var import_node_os2 = __toESM(require('node:os'), 1);
var import_node_tty2 = __toESM(require('node:tty'), 1);
function hasFlag2(flag, argv = import_node_process4.default.argv) {
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return (
    position !== -1 &&
    (terminatorPosition === -1 || position < terminatorPosition)
  );
}
var { env: env2 } = import_node_process4.default;
var flagForceColor2;
if (
  hasFlag2('no-color') ||
  hasFlag2('no-colors') ||
  hasFlag2('color=false') ||
  hasFlag2('color=never')
) {
  flagForceColor2 = 0;
} else if (
  hasFlag2('color') ||
  hasFlag2('colors') ||
  hasFlag2('color=true') ||
  hasFlag2('color=always')
) {
  flagForceColor2 = 1;
}
function envForceColor2() {
  if ('FORCE_COLOR' in env2) {
    if (env2.FORCE_COLOR === 'true') {
      return 1;
    }
    if (env2.FORCE_COLOR === 'false') {
      return 0;
    }
    return env2.FORCE_COLOR.length === 0
      ? 1
      : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
  }
}
function translateLevel2(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3,
  };
}
function _supportsColor2(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor2();
  if (noFlagForceColor !== void 0) {
    flagForceColor2 = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor2 : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (
      hasFlag2('color=16m') ||
      hasFlag2('color=full') ||
      hasFlag2('color=truecolor')
    ) {
      return 3;
    }
    if (hasFlag2('color=256')) {
      return 2;
    }
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env2.TERM === 'dumb') {
    return min;
  }
  if (import_node_process4.default.platform === 'win32') {
    const osRelease = import_node_os2.default.release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ('CI' in env2) {
    if (
      [
        'TRAVIS',
        'CIRCLECI',
        'APPVEYOR',
        'GITLAB_CI',
        'GITHUB_ACTIONS',
        'BUILDKITE',
        'DRONE',
      ].some((sign) => sign in env2) ||
      env2.CI_NAME === 'codeship'
    ) {
      return 1;
    }
    return min;
  }
  if ('TEAMCITY_VERSION' in env2) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  }
  if ('TF_BUILD' in env2 && 'AGENT_NAME' in env2) {
    return 1;
  }
  if (env2.COLORTERM === 'truecolor') {
    return 3;
  }
  if ('TERM_PROGRAM' in env2) {
    const version = Number.parseInt(
      (env2.TERM_PROGRAM_VERSION || '').split('.')[0],
      10,
    );
    switch (env2.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Apple_Terminal':
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env2.TERM)) {
    return 2;
  }
  if (
    /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
      env2.TERM,
    )
  ) {
    return 1;
  }
  if ('COLORTERM' in env2) {
    return 1;
  }
  return min;
}
function createSupportsColor2(stream, options = {}) {
  const level = _supportsColor2(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options,
  });
  return translateLevel2(level);
}
var supportsColor2 = {
  stdout: createSupportsColor2({ isTTY: import_node_tty2.default.isatty(1) }),
  stderr: createSupportsColor2({ isTTY: import_node_tty2.default.isatty(2) }),
};
var supports_color_default2 = supportsColor2;

// ../node_modules/log-symbols/node_modules/chalk/source/utilities.js
function stringReplaceAll2(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = '';
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex2(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = '';
  do {
    const gotCR = string[index - 1] === '\r';
    returnValue +=
      string.slice(endIndex, gotCR ? index - 1 : index) +
      prefix +
      (gotCR ? '\r\n' : '\n') +
      postfix;
    endIndex = index + 1;
    index = string.indexOf('\n', endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../node_modules/log-symbols/node_modules/chalk/source/index.js
var { stdout: stdoutColor2, stderr: stderrColor2 } = supports_color_default2;
var GENERATOR2 = Symbol('GENERATOR');
var STYLER2 = Symbol('STYLER');
var IS_EMPTY2 = Symbol('IS_EMPTY');
var levelMapping2 = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
var styles4 = /* @__PURE__ */ Object.create(null);
var applyOptions2 = (object, options = {}) => {
  if (
    options.level &&
    !(
      Number.isInteger(options.level) &&
      options.level >= 0 &&
      options.level <= 3
    )
  ) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }
  const colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory2 = (options) => {
  const chalk3 = (...strings) => strings.join(' ');
  applyOptions2(chalk3, options);
  Object.setPrototypeOf(chalk3, createChalk2.prototype);
  return chalk3;
};
function createChalk2(options) {
  return chalkFactory2(options);
}
Object.setPrototypeOf(createChalk2.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default2)) {
  styles4[styleName] = {
    get() {
      const builder = createBuilder2(
        this,
        createStyler2(style.open, style.close, this[STYLER2]),
        this[IS_EMPTY2],
      );
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    },
  };
}
styles4.visible = {
  get() {
    const builder = createBuilder2(this, this[STYLER2], true);
    Object.defineProperty(this, 'visible', { value: builder });
    return builder;
  },
};
var getModelAnsi2 = (model, level, type, ...arguments_) => {
  if (model === 'rgb') {
    if (level === 'ansi16m') {
      return ansi_styles_default2[type].ansi16m(...arguments_);
    }
    if (level === 'ansi256') {
      return ansi_styles_default2[type].ansi256(
        ansi_styles_default2.rgbToAnsi256(...arguments_),
      );
    }
    return ansi_styles_default2[type].ansi(
      ansi_styles_default2.rgbToAnsi(...arguments_),
    );
  }
  if (model === 'hex') {
    return getModelAnsi2(
      'rgb',
      level,
      type,
      ...ansi_styles_default2.hexToRgb(...arguments_),
    );
  }
  return ansi_styles_default2[type][model](...arguments_);
};
var usedModels2 = ['rgb', 'hex', 'ansi256'];
for (const model of usedModels2) {
  styles4[model] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler2(
          getModelAnsi2(model, levelMapping2[level], 'color', ...arguments_),
          ansi_styles_default2.color.close,
          this[STYLER2],
        );
        return createBuilder2(this, styler, this[IS_EMPTY2]);
      };
    },
  };
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles4[bgModel] = {
    get() {
      const { level } = this;
      return function (...arguments_) {
        const styler = createStyler2(
          getModelAnsi2(model, levelMapping2[level], 'bgColor', ...arguments_),
          ansi_styles_default2.bgColor.close,
          this[STYLER2],
        );
        return createBuilder2(this, styler, this[IS_EMPTY2]);
      };
    },
  };
}
var proto2 = Object.defineProperties(() => {}, {
  ...styles4,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR2].level;
    },
    set(level) {
      this[GENERATOR2].level = level;
    },
  },
});
var createStyler2 = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent,
  };
};
var createBuilder2 = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) =>
    applyStyle2(
      builder,
      arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '),
    );
  Object.setPrototypeOf(builder, proto2);
  builder[GENERATOR2] = self;
  builder[STYLER2] = _styler;
  builder[IS_EMPTY2] = _isEmpty;
  return builder;
};
var applyStyle2 = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY2] ? '' : string;
  }
  let styler = self[STYLER2];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes('\x1B')) {
    while (styler !== void 0) {
      string = stringReplaceAll2(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex2(
      string,
      closeAll,
      openAll,
      lfIndex,
    );
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk2.prototype, styles4);
var chalk2 = createChalk2();
var chalkStderr2 = createChalk2({
  level: stderrColor2 ? stderrColor2.level : 0,
});
var source_default2 = chalk2;

// ../node_modules/is-unicode-supported/index.js
var import_node_process5 = __toESM(require('node:process'), 1);
function isUnicodeSupported() {
  if (import_node_process5.default.platform !== 'win32') {
    return import_node_process5.default.env.TERM !== 'linux';
  }
  return (
    Boolean(import_node_process5.default.env.CI) ||
    Boolean(import_node_process5.default.env.WT_SESSION) ||
    Boolean(import_node_process5.default.env.TERMINUS_SUBLIME) ||
    import_node_process5.default.env.ConEmuTask === '{cmd::Cmder}' ||
    import_node_process5.default.env.TERM_PROGRAM === 'Terminus-Sublime' ||
    import_node_process5.default.env.TERM_PROGRAM === 'vscode' ||
    import_node_process5.default.env.TERM === 'xterm-256color' ||
    import_node_process5.default.env.TERM === 'alacritty' ||
    import_node_process5.default.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm'
  );
}

// ../node_modules/log-symbols/index.js
var main = {
  info: source_default2.blue('\u2139'),
  success: source_default2.green('\u2714'),
  warning: source_default2.yellow('\u26A0'),
  error: source_default2.red('\u2716'),
};
var fallback = {
  info: source_default2.blue('i'),
  success: source_default2.green('\u221A'),
  warning: source_default2.yellow('\u203C'),
  error: source_default2.red('\xD7'),
};
var logSymbols = isUnicodeSupported() ? main : fallback;
var log_symbols_default = logSymbols;

// ../node_modules/ora/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
  ].join('|');
  return new RegExp(pattern, onlyFirst ? void 0 : 'g');
}

// ../node_modules/ora/node_modules/strip-ansi/index.js
function stripAnsi(string) {
  if (typeof string !== 'string') {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(ansiRegex(), '');
}

// ../node_modules/ora/index.js
var import_wcwidth = __toESM(require_wcwidth(), 1);

// ../node_modules/is-interactive/index.js
function isInteractive({ stream = process.stdout } = {}) {
  return Boolean(
    stream &&
      stream.isTTY &&
      process.env.TERM !== 'dumb' &&
      !('CI' in process.env),
  );
}

// ../node_modules/ora/utilities.js
var import_node_process6 = __toESM(require('node:process'), 1);
var import_node_readline = __toESM(require('node:readline'), 1);
var import_bl = __toESM(require_bl(), 1);
var ASCII_ETX_CODE = 3;
var StdinDiscarder = class {
  #requests = 0;
  #mutedStream = new import_bl.BufferListStream();
  #ourEmit;
  #rl;
  constructor() {
    this.#mutedStream.pipe(import_node_process6.default.stdout);
    const self = this;
    this.#ourEmit = function (event, data, ...args) {
      const { stdin } = import_node_process6.default;
      if (self.#requests > 0 || stdin.emit === self.#ourEmit) {
        if (event === 'keypress') {
          return;
        }
        if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
          import_node_process6.default.emit('SIGINT');
        }
        Reflect.apply(self.#ourEmit, this, [event, data, ...args]);
      } else {
        Reflect.apply(import_node_process6.default.stdin.emit, this, [
          event,
          data,
          ...args,
        ]);
      }
    };
  }
  start() {
    this.#requests++;
    if (this.#requests === 1) {
      this._realStart();
    }
  }
  stop() {
    if (this.#requests <= 0) {
      throw new Error('`stop` called more times than `start`');
    }
    this.#requests--;
    if (this.#requests === 0) {
      this._realStop();
    }
  }
  _realStart() {
    if (import_node_process6.default.platform === 'win32') {
      return;
    }
    this.#rl = import_node_readline.default.createInterface({
      input: import_node_process6.default.stdin,
      output: this.#mutedStream,
    });
    this.#rl.on('SIGINT', () => {
      if (import_node_process6.default.listenerCount('SIGINT') === 0) {
        import_node_process6.default.emit('SIGINT');
      } else {
        this.#rl.close();
        import_node_process6.default.kill(
          import_node_process6.default.pid,
          'SIGINT',
        );
      }
    });
  }
  _realStop() {
    if (import_node_process6.default.platform === 'win32') {
      return;
    }
    this.#rl.close();
    this.#rl = void 0;
  }
};

// ../node_modules/ora/index.js
var stdinDiscarder;
var Ora = class {
  #linesToClear = 0;
  #isDiscardingStdin = false;
  #lineCount = 0;
  #frameIndex = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  color;
  constructor(options) {
    if (!stdinDiscarder) {
      stdinDiscarder = new StdinDiscarder();
    }
    if (typeof options === 'string') {
      options = {
        text: options,
      };
    }
    this.#options = {
      color: 'cyan',
      stream: import_node_process7.default.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options,
    };
    this.color = this.#options.color;
    this.spinner = this.#options.spinner;
    this.#initialInterval = this.#options.interval;
    this.#stream = this.#options.stream;
    this.#isEnabled =
      typeof this.#options.isEnabled === 'boolean'
        ? this.#options.isEnabled
        : isInteractive({ stream: this.#stream });
    this.#isSilent =
      typeof this.#options.isSilent === 'boolean'
        ? this.#options.isSilent
        : false;
    this.text = this.#options.text;
    this.prefixText = this.#options.prefixText;
    this.indent = this.#options.indent;
    if (import_node_process7.default.env.NODE_ENV === 'test') {
      this._stream = this.#stream;
      this._isEnabled = this.#isEnabled;
      Object.defineProperty(this, '_linesToClear', {
        get() {
          return this.#linesToClear;
        },
        set(newValue) {
          this.#linesToClear = newValue;
        },
      });
      Object.defineProperty(this, '_frameIndex', {
        get() {
          return this.#frameIndex;
        },
      });
      Object.defineProperty(this, '_lineCount', {
        get() {
          return this.#lineCount;
        },
      });
    }
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error('The `indent` option must be an integer from 0 and up');
    }
    this.#indent = indent;
    this.updateLineCount();
  }
  get interval() {
    return this.#initialInterval || this.#spinner.interval || 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner2) {
    this.#frameIndex = 0;
    this.#initialInterval = void 0;
    if (typeof spinner2 === 'object') {
      if (spinner2.frames === void 0) {
        throw new Error('The given spinner must have a `frames` property');
      }
      this.#spinner = spinner2;
    } else if (!isUnicodeSupported()) {
      this.#spinner = import_cli_spinners.default.line;
    } else if (spinner2 === void 0) {
      this.#spinner = import_cli_spinners.default.dots;
    } else if (
      spinner2 !== 'default' &&
      import_cli_spinners.default[spinner2]
    ) {
      this.#spinner = import_cli_spinners.default[spinner2];
    } else {
      throw new Error(
        `There is no built-in spinner named '${spinner2}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`,
      );
    }
  }
  get text() {
    return this.#text;
  }
  set text(value) {
    this.#text = value || '';
    this.updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value) {
    this.#prefixText = value || '';
    this.updateLineCount();
  }
  get isSpinning() {
    return this.#id !== void 0;
  }
  getFullPrefixText(prefixText = this.#prefixText, postfix = ' ') {
    if (typeof prefixText === 'string' && prefixText !== '') {
      return prefixText + postfix;
    }
    if (typeof prefixText === 'function') {
      return prefixText() + postfix;
    }
    return '';
  }
  updateLineCount() {
    const columns = this.#stream.columns || 80;
    const fullPrefixText = this.getFullPrefixText(this.#prefixText, '-');
    this.#lineCount = 0;
    for (const line of stripAnsi(
      ' '.repeat(this.#indent) + fullPrefixText + '--' + this.#text,
    ).split('\n')) {
      this.#lineCount += Math.max(
        1,
        Math.ceil((0, import_wcwidth.default)(line) / columns),
      );
    }
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value !== 'boolean') {
      throw new TypeError('The `isEnabled` option must be a boolean');
    }
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value !== 'boolean') {
      throw new TypeError('The `isSilent` option must be a boolean');
    }
    this.#isSilent = value;
  }
  frame() {
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    this.#frameIndex = ++this.#frameIndex % frames.length;
    const fullPrefixText =
      typeof this.#prefixText === 'string' && this.#prefixText !== ''
        ? this.#prefixText + ' '
        : '';
    const fullText = typeof this.text === 'string' ? ' ' + this.text : '';
    return fullPrefixText + frame + fullText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY) {
      return this;
    }
    this.#stream.cursorTo(0);
    for (let index = 0; index < this.#linesToClear; index++) {
      if (index > 0) {
        this.#stream.moveCursor(0, -1);
      }
      this.#stream.clearLine(1);
    }
    if (this.#indent || this.lastIndent !== this.#indent) {
      this.#stream.cursorTo(this.#indent);
    }
    this.lastIndent = this.#indent;
    this.#linesToClear = 0;
    return this;
  }
  render() {
    if (this.#isSilent) {
      return this;
    }
    this.clear();
    this.#stream.write(this.frame());
    this.#linesToClear = this.#lineCount;
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (this.#isSilent) {
      return this;
    }
    if (!this.#isEnabled) {
      if (this.text) {
        this.#stream.write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (this.#options.hideCursor) {
      cli_cursor_default.hide(this.#stream);
    }
    if (
      this.#options.discardStdin &&
      import_node_process7.default.stdin.isTTY
    ) {
      this.#isDiscardingStdin = true;
      stdinDiscarder.start();
    }
    this.render();
    this.#id = setInterval(this.render.bind(this), this.interval);
    return this;
  }
  stop() {
    if (!this.#isEnabled) {
      return this;
    }
    clearInterval(this.#id);
    this.#id = void 0;
    this.#frameIndex = 0;
    this.clear();
    if (this.#options.hideCursor) {
      cli_cursor_default.show(this.#stream);
    }
    if (
      this.#options.discardStdin &&
      import_node_process7.default.stdin.isTTY &&
      this.#isDiscardingStdin
    ) {
      stdinDiscarder.stop();
      this.#isDiscardingStdin = false;
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.info, text });
  }
  stopAndPersist(options = {}) {
    if (this.#isSilent) {
      return this;
    }
    const prefixText = options.prefixText || this.#prefixText;
    const text = options.text || this.text;
    const fullText = typeof text === 'string' ? ' ' + text : '';
    this.stop();
    this.#stream.write(`${this.getFullPrefixText(prefixText, ' ')}${
      options.symbol || ' '
    }${fullText}
`);
    return this;
  }
};
function ora(options) {
  return new Ora(options);
}

// src/utils/spinners.ts
var spinner = ora({
  spinner: 'star',
});
var updateSpinnerText = (message) => {
  if (spinner.isSpinning) {
    spinner.text = message;
    return;
  }
  spinner.start(message);
};
var spinnerSuccess = (message) => {
  if (spinner.isSpinning) {
    spinner.succeed(message);
  }
};

// src/index.ts
var program2 = new Command();
program2.description(
  'A simple CLI tool for generating front end design system packages.',
);
program2.option('--verbose', 'Verbose logging.');
program2.version('0.1.0', '-v, --version', 'Logs current version.');
program2.command('generate:tokens').action(() =>
  __async(exports, null, function* () {
    updateSpinnerText('Generating tokens...');
    yield new Promise((resolve) => setTimeout(resolve, 3e3));
    spinnerSuccess();
    console.log('wow your tokens!');
  }),
);
program2
  .command('generate:ui')
  .option('--name -n', 'Name of the package.')
  .action(() =>
    __async(exports, null, function* () {
      updateSpinnerText('Generating UI...');
      yield new Promise((resolve) => setTimeout(resolve, 3e3));
      const libName = 'skeletor-ui';
      console.log('Creating directory...');
      fs.mkdirSync(libName);
      console.log('Scaffolding package.json...');
      fs.writeFileSync(
        `${libName}/package.json`,
        JSON.stringify(
          {
            name: libName,
            version: '0.1.0',
            description: 'A simple UI library generated by Skeletor.',
            main: 'dist/cjs/index.js',
            module: 'dist/esm/index.js',
            files: ['dist'],
            types: './dist/index.d.ts',
            scripts: {
              build:
                'rimraf dist && tsc --emitDeclarationOnly && NODE_ENV=production rollup --config',
              tsc: 'tsc',
            },
            author: 'skeletor-cli',
            license: 'UNLICENSED',
            devDependencies: {
              '@babel/core': '^7.14.3',
              '@babel/preset-env': '^7.14.2',
              '@babel/preset-react': '^7.13.13',
              '@rollup/plugin-babel': '^5.3.0',
              '@rollup/plugin-commonjs': '^17.1.0',
              '@rollup/plugin-node-resolve': '^11.2.1',
              '@rollup/plugin-typescript': '^8.2.1',
              '@types/react': '^17.0.3',
              '@types/react-dom': '^17.0.3',
              'babel-loader': '^8.2.2',
              react: '^18.2.0',
              'react-dom': '^18.2.0',
              typescript: '^4.3.5',
              rimraf: '^3.0.2',
              rollup: '^2.52.1',
              'rollup-plugin-peer-deps-external': '^2.2.4',
              'rollup-plugin-dts': '^3.0.1',
              webpack: '^5.52.1',
            },
          },
          null,
          2,
        ),
      );
      console.log('Adding tsconfig.json...');
      fs.writeFileSync(
        `${libName}/tsconfig.json`,
        JSON.stringify(
          {
            compilerOptions: {
              target: 'es5',
              jsx: 'react',
              module: 'esnext',
              rootDir: './src',
              lib: ['es6', 'dom', 'es2016', 'es2017'],
              moduleResolution: 'node',
              resolveJsonModule: true,
              allowJs: false,
              declaration: true,
              declarationDir: 'types',
              sourceMap: true,
              outDir: './dist',
              allowSyntheticDefaultImports: true,
              esModuleInterop: true,
              forceConsistentCasingInFileNames: true,
              strict: true,
              skipLibCheck: true,
              emitDeclarationOnly: true,
            },
            include: ['src/**/*'],
            exclude: ['node_modules', 'dist'],
          },
          null,
          2,
        ),
      );
      console.log('Creating directories...');
      fs.mkdirSync(`${libName}/src`);
      fs.mkdirSync(`${libName}/src/components`);
      fs.mkdirSync(`${libName}/src/components/Button`);
      console.log('Adding index.ts and first component...');
      fs.writeFileSync(
        `${libName}/src/index.ts`,
        `export { default as Button } from './components/Button';`,
      );
      fs.writeFileSync(
        `${libName}/src/components/Button/button.ts`,
        `
      import React from 'react';

      export interface ButtonProps {
        label: string;
      }

      export const Button = ({ label }: ButtonProps) => {
        return (
          <button>{label}</button>
        );
      };
    `,
      );
      console.log('Adding rollup.config.js...');
      fs.writeFileSync(
        `${libName}/rollup.config.js`,
        `
      import resolve from '@rollup/plugin-node-resolve';
      import commonjs from '@rollup/plugin-commonjs';
      import external from 'rollup-plugin-peer-deps-external';
      import typescript from '@rollup/plugin-typescript';
      import dts from 'rollup-plugin-dts';
      import babel from '@rollup/plugin-babel';
      import pkg from './package.json';

      export default [
        {
          input: ['src/index.ts'],
          output: [
            {
              file: pkg.main,
              format: 'cjs',
              sourcemap: true,
              name: 'react-ts-lib',
            },
            {
              file: pkg.module,
              format: 'esm',
              sourcemap: true,
            },
          ],
          plugins: [
            babel({
              babelHelpers: 'bundled',
            }),
            external(),
            resolve(),
            commonjs(),
            typescript({
              tsconfig: './tsconfig.json',
            }),
          ],
          external: ['react', 'react-dom'],
        },
        {
          input: 'dist/esm/types/index.d.ts',
          output: [
            {
              file: 'dist/index.d.ts',
              format: 'esm',
            },
          ],
          external: [/.css$/],
          plugins: [dts()],
        },
      ];`,
      );
      console.log('Adding a README...');
      fs.writeFileSync(
        `${libName}/README.md`,
        `# ${libName}

      A simple UI library generated by Skeletor. \u{1F480}`,
      );
      console.log('Adding a few extras...');
      fs.writeFileSync(`${libName}/.gitignore`, 'node_modules');
      fs.writeFileSync(
        `${libName}/.babelrc`,
        `
      {
        "presets": ["@babel/preset-env", "@babel/preset-react"]
      }
    `,
      );
      console.log('Package generated! \u{1F389}');
      console.log(`cd ${libName} && npm install`);
      updateSpinnerText(`cd ${libName} && npm install`);
      spinnerSuccess();
    }),
  );
var run = () =>
  __async(exports, null, function* () {
    yield program2.parseAsync();
  });
run();
process.on('unhandledRejection', function (err) {
  const debug = program2.opts().verbose;
  if (debug) {
    console.error(err.stack);
  }
  program2.error('', { exitCode: 1 });
});
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
